<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【程序员的自我修养】[动态图文] 理解编译到链接的过程 [编译与链接一]</title>
    <url>/posts/Compile-And-Link.html</url>
    <content><![CDATA[<h1 id="程序的编译及链接"><a href="#程序的编译及链接" class="headerlink" title="程序的编译及链接"></a>程序的编译及链接</h1><p>在学习C语言的过程中，每一个 <code>.c</code> 文件都会经过 <code>编译链接</code> 等 <code>预处理</code> 操作才能成为一个 <code>.exe</code> 的可执行文件的</p>
<p>这些 <code>预处理</code> 过程到底是如何进行的，就是本篇文章的内容</p>
<span id="more"></span>

<h2 id="一、程序的翻译环境和执行环境"><a href="#一、程序的翻译环境和执行环境" class="headerlink" title="一、程序的翻译环境和执行环境"></a>一、程序的翻译环境和执行环境</h2><p>一般写出的 <code>.c</code> 后缀的 源代码文件，是不能直接执行的。<br>类似 <code>.c</code> 的源代码文件要变成  类似 <code>.exe</code> 后缀的 可执行文件，再到可执行[[程序的运行]]实现 是要经过两个环境的：<code>翻译环境</code> <code>执行环境</code></p>
<p>大致的过程是：</p>
<ol>
<li>一个源代码文件，由翻译环境翻译为 计算机能够直接看懂的 二进制指令（机器指令），即生成可执行程序： 类似 <code>.exe</code> 后缀的文件（不同系统环境下的可执行程序的后缀是不同的）</li>
<li>可执行[[程序的运行]]实现，就需要 通过运行环境 来实现</li>
</ol>
<p>即：</p>
<blockquote>
<p>   在ANSI C的任何一种实现中，存在两个不同的环境。<br>   第1种是 <code>翻译环境</code>，在这个环境中源代码被转换为可执行的机器指令。<br>   第2种是 <code>执行环境</code>，它用于实际执行代码</p>
</blockquote>
<h3 id="1-1-翻译环境"><a href="#1-1-翻译环境" class="headerlink" title="1. 1 翻译环境"></a>1. 1 翻译环境</h3><p>翻译环境可以简单的分为两个过程： <code>编译</code> 和 <code>链接</code><br>编译的作用是，将一个项目中的每一个源代码文件(<code>.c</code> 后缀等)，都单独处理为 对应的目标文件(VS编译器 环境下<code>.obj</code> 后缀，GCC编译器 环境下 <code>.o</code>后缀)</p>
<p>而链接，则是将编译生成的 <code>.obj</code> 目标文件与所其涉及到的静态库，一起进行链接，最终生成 <code>.exe</code> 后缀的可执行文件</p>
<blockquote>
<p>📌<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/%E4%BC%98%E5%8C%96_%E7%BC%96%E8%AF%91_%E9%93%BE%E6%8E%A5.gif" alt="优化_编译_链接"></p>
<p>在这一整个过程中，<code>编译器</code>来完成编译操作，<code>链接器</code>来完成链接操作</p>
</blockquote>
<p>在编译链接的过程中，除了源文件(<code>.c</code>后缀)和目标文件(<code>.obj</code>或<code>o</code>后缀)，还提到了一个名词：<code>静态库</code> 也可以被称作 <code>静态链接库</code>。</p>
<blockquote>
<p>📌<br><code>静态库链接库</code>是什么？</p>
<p>编写C语言代码使用的一些函数，例如:<br><code>printf</code> <code>scanf</code> 等等，<br>这些函数，并不属于编写者所自定义的函数。这些函数是由 C 语言默认提供的。这些由 C 语言默认提供的函数，一般都存放在各自的库中：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/printf%E9%9D%99%E6%80%81%E5%BA%93.png" alt="printf"><br>像以上 <code>LIBC.LIB</code> 、 <code>LIBCMT.LIB</code> 、<code>MSVCRT.LIB</code> 都属于静态库，<code>printf</code> 函数就存在于这三个 <code>静态链接库</code> 中 </p>
</blockquote>
<p>如果在编写的 源代码文件 中，使用到了存在于某些 <code>静态链接库里的库函数</code><br>那么在链接的时候，就会将 <code>所使用函数的静态库</code> 与 <code>编译生成的目标文件</code> 一起链接起来，以致于可执行程序可以正常执行。</p>
<p>以上的编译过程可以细分为三个过程：预编译、编译、汇编</p>
<h3 id="1-2-翻译详解"><a href="#1-2-翻译详解" class="headerlink" title="1.2 翻译详解"></a>1.2 翻译详解</h3><p>上面了解到，由源代码到可执行程序的过程是要经过 <code>翻译环境</code> 的一系列操作的，翻译环境大方面分为 <code>编译</code> <code>链接</code> 两个大过程，而编译又可以细分为：预编译([[预处理]])、编译、汇编 三个详细过程。<br>下面是编译的三个详细过程的详解：</p>
<blockquote>
<pre><code>         以下 均为 Linux平台-GCC编译环境下 的演示效果
</code></pre>
</blockquote>
<h4 id="1-2-1-预编译"><a href="#1-2-1-预编译" class="headerlink" title="1.2.1 预编译"></a>1.2.1 预编译</h4><p>预编译是干什么的？<br>预编译，一般进行三项操作：</p>
<ol>
<li>对 头文件的包含、展开</li>
<li>对 注释的删除</li>
<li>对 <code>#define</code> 所宏定义符号的转换</li>
</ol>
<p>干巴巴的只用文字表述，其实没有办法简单直观的理解这三项操作，所以用图片来演示：</p>
<p>对三项操作一 一进行展示：</p>
<blockquote>
<p>📌 对头文件的包含、展开<br>Linux 环境下编写简单的一段代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>        <span class="token comment">//头文件</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST.png" alt="Linux-test"><br>然后用 GCC 编译器对 test.c 文件进行[[预处理]]，并将[[预处理]]后的文件信息输出至 test.i 文件中：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-E.png" alt="GCC -E"></p>
<blockquote>
<p>✔️小知识：<br><code>gcc -E (源代码文件) 或 gcc (源代码文件) -E</code> 对源代码进行预编译<br><code>gcc -E (源代码文件) -o (指定预处理文件)或 gcc (源代码文件) -E -o (指定预处理文件)</code> 对源代码进行[[预处理]]并输出至指定文件内</p>
</blockquote>
<p>可以看到 路径下生成 test.i 文件，最后一部分内容为：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-i.png" alt="TEST-i"><br>除了最后的几行代码，以上并不是原文件中的代码，并且 原代码文件中<code>#include &lt;stdio.h&gt;</code> 对头文件的包含消失不见<br>以上的内容与 stdio.h 部分内容做对比：<br><code>stdio.h</code> 部分内容：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-STDIO.png" alt="stdio.h"><br>很容易发现，两文件中关键代码是相同的<br>所以可以肯定，<code>预编译过程中，编译器对源代码进行了 头文件的包含、展开的操作</code></p>
</blockquote>
<blockquote>
<p>📌 对注释的删除<br>在上面两个文件做对比的时候，细心观察可以发现，两个文件所包含的相同的头文件的代码行数是不相同的<br>再一对比，可以看出 <code>test.i</code>  文件中并没有蓝色的注释部分<br>说明预编译，对源代码也进行了 删除注释 的操作<br>还有一个更直观的 展示方法（使用以下代码进行预编译操作）(可以直接再 <code>test.c</code> 文件中添加)：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 这是头文件的包含</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stido.h></span></span>
<span class="token comment">// 这是程序主函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">// 这是一个 printf 函数</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span>

	<span class="token comment">// 这是主函数的返回操作</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-Annotation.png" alt="TEST-Annotation"><br>对以上代码进行预编译操作，并查看预编译后的文件内容：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-VIM-TEST-i-Annotation.png" alt="READ-TEST.i"><br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-E-Annotation.png" alt="GCC-PRE-E-Annotation"><br>同样可以看出，预编译后的代码中，注释内容被删除了，也可以说是被空格替换掉了<br>所以，<code>预编译过程中，编译器源代码进行了 删除注释 的操作</code></p>
</blockquote>
<blockquote>
<p>📌 对 #define 宏定义符号的替换<br>还是不同的代码，同样的操作<br>使用以下代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">3</span> <span class="token expression">THREE  </span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">666</span> <span class="token expression">CSDN</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> THREE<span class="token punctuation">;</span>
	<span class="token keyword">int</span> y <span class="token operator">=</span> CSDN<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-Macro.png" alt="TEST-Macro"><br>预编译处理：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-E-Macro.png" alt="GCC-PRE-E-Macro"><br><code>test.i</code> 部分内容:<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-i-Macro-READ.png" alt="TEST-i-Macro-READ"></p>
<p>源代码中的 两句宏定义 语句被删除，函数中使用的宏定义符号 被替换为 原本的数值</p>
<p>可以说明，<code>预编译过程中，编译器对源代码进行了 替换宏定义符号 的操作</code></p>
</blockquote>
<p>以上的三种示例，可以说明预编译过程 一般是对源代码进行的一些 <code>文本的删除、替换、文件文本的包含、展开等</code>。<br>所以可以说，<code>预编译 一般是对源代码 进行一系列的文本操作</code></p>
<hr>
<h4 id="1-2-2-编译"><a href="#1-2-2-编译" class="headerlink" title="1.2.2 编译"></a>1.2.2 编译</h4><p>经过预编译后的源代码文件，已经除去了许多对计算机来说没有用的信息(比如 注释，注释一般是写给操作者看的，计算机不需要注释)</p>
<p><code>预编译</code> 的作用一般是对源代码进行 <code>文本操作</code> ，那么 <code>编译</code> 的具体作用是什么呢？</p>
<p>我们通过对上面某个已经 经过预编译的文件 进行编译:</p>
<blockquote>
<p>📌<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-S.png" alt="GCC-PRE-S"></p>
<blockquote>
<p>✔️小知识：<br><code>gcc -S (经过预编译的文件) 或 gcc (经过预编译的文件) -S</code><br>可以对已经经过预编译的文件进行编译，自动输出到 文件对应的以 <code>.s</code> 为后缀的文件</p>
</blockquote>
<p>查看 <code>test.s</code> 的具体内容：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-VIM-TEST-S.png" alt="VIM-TEST-S"></p>
<p>查看 <code>test.s</code> 的内容不难发现，它的内容都是 <code>汇编代码</code> </p>
<p>所以，预编译之后的编译操作，其实是将 <code>经过预编译的代码</code>  转变为 <code>对应的汇编代码指令</code></p>
<p>编译的作用就是，把 <code>C语言代码</code> 转变成 <code>相应的汇编代码</code></p>
<blockquote>
<p>编译这个过程的细节一般还会分为:</p>
<ol>
<li><code> 语法分析</code></li>
<li><code> 词法分析</code></li>
<li><code> 语义分析</code></li>
<li><code> 符号汇总</code></li>
</ol>
</blockquote>
<p>更加细节的内容不在这里赘述。(以后有机会再详细介绍一下)</p>
</blockquote>
<h4 id="1-2-3-汇编"><a href="#1-2-3-汇编" class="headerlink" title="1.2.3 汇编"></a>1.2.3 汇编</h4><p>汇编 是对 汇编代码 进行的操作，汇编的作用是将 汇编代码 转换成 计算机可以直接识别的 <code>机器指令</code> 即，<code>二进制指令</code>。</p>
<p>对 <code>test.s</code> 文件进行汇编操作：</p>
<blockquote>
<p>📌<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-C.png" alt="GCC-PRE-C"></p>
<blockquote>
<p>✔️小知识：<br><code>gcc -c (经过预编译的文件) 或 gcc (经过预编译的文件) -c</code><br><code>(注意此处 -c 中，c 为小写)</code><br>可以对汇编代码文件进行汇编操作，将生成的二进制指令 输出到对应的以 <code>.o</code> 为后缀的文件中<br><code>.o</code> 后缀的文件，就是 <code>GCC环境</code> 生成的目标文件</p>
</blockquote>
<p>查看 <code>.o</code> 目标文件：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-O.png" alt="TEST-O"><br><code>vim</code> 打开，可以看出 目标文件几乎都是乱码。其实只是计算机可以直接识别的二进制的指令。</p>
<p>所以，<code>汇编操作</code> 是将 <code>汇编代码</code> 转换为 <code>机器指令（二进制指令）</code>。</p>
</blockquote>
<hr>
<p>以上三段过程，是翻译环境中 编译的整个过程，而翻译最重要的环节之一，还有：链接：</p>
<hr>
<h4 id="1-2-4-链接-及-结果"><a href="#1-2-4-链接-及-结果" class="headerlink" title="1.2.4 链接 及 结果"></a>1.2.4 链接 及 结果</h4><p>链接，是对项目中所有的目标文件进行链接的，如果想要展示出链接的作用，可以编写多个 <code>.c</code> 文件进行编译，再将所有的 <code>.o</code> 文件 进行链接。</p>
<blockquote>
<p>📌</p>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token comment">// add.c</span>
<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">ADD</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
<span class="token operator">></span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token comment">// sub.c</span>
<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">SUB</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
<span class="token operator">></span><span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token comment">// test.c</span>
<span class="token operator">></span>#include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span>
<span class="token operator">></span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">ADD</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">SUB</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">ADD</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dev <span class="token operator">=</span> <span class="token function">SUB</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dev = %d\n"</span><span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
       
   	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p><code>vim</code>：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-LINK-ADD-C.png" alt="add.c"><br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-LINK-SUB-C.png" alt="sub.c"><br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-LINK-TEST-C.png" alt="test.c"></p>
<p>然后，分别对 <code>add.c</code> 、<code>sub.c</code>、 <code>test.c</code> 三个<code>.c</code> 文件，预编译、编译、汇编：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-PROJECT-E-S-c.png" alt="PROJECT-E-S-c"><br>最终生成对应的：<code>add.o</code> 、<code>sub.o</code> 、<code>test.o</code></p>
<p>最后对 <code>所有的目标文件</code> 进行链接<br><code>（用户不用主动在意静态库，链接器会自动链接）</code>：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-PROJECT-LINK.png" alt="PROJECT-LINK"></p>
<blockquote>
<p>✔️小知识：<br><code>gcc (所有的目标文件)</code> 即可将所有目标文件链接在一起，生成可执行程序。<br>后接 <code>-o (指定程序名)</code> <code>gcc (所有的目标文件) -o (指定程序名)</code><br>可生成指定文件名的可执行文件</p>
</blockquote>
<p>为了做对比，直接对 <code>add.c</code> 、<code>sub.c</code> 、<code>test.c</code> 进行编译链接<br>方便进行对比：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-PROJECT-GCC.png" alt="PROJECT-GCC"><br>直接编译链接，不指定文件名，生成  <code>a.out</code> 可执行程序</p>
<p>分别运行 <code>test</code> 、<code>a.out</code></p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-PROJECT-RUN.png" alt="PROJECT-RUN"></p>
<p><code>test</code> 、<code>a.out</code> 两程序运行结果相同，说明 拆解过程的编译链接 及 直接的编译链接 结果是一样的</p>
<p>可以说明，一个项目 在翻译环境中的整个过程确实为：</p>
<ol>
<li>编译<br>a. 预编译 <code>(删除原代码中的注释、对头文件进行包含.展开、对宏符号进行转换 等)</code><br>b. 编译 <code>(将 C 语言代码文件 转换为 对应的汇编代码文件)</code><br>c. 汇编 <code>(将 汇编代码文件 转换为 对应的机器指令文件（目标文件）)</code></li>
<li>链接 <code>(将 所有目标文件 及 静态库 链接 生成可执行文件)</code></li>
</ol>
<p>那么，项目文件从 <code>.c</code> 到 可执行文件的过程 可以简单的详细为：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/Pre-More.gif" alt="Pre-More"></p>
</blockquote>
]]></content>
      <categories>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>【神秘海域】[动图] 数据结构与算法初探：复杂度详解分析 「附代码」</title>
    <url>/posts/DS-Complexity.html</url>
    <content><![CDATA[<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/DS_Cover_Com.jpg"></p>
<hr>
<h1 id="复杂度-引言"><a href="#复杂度-引言" class="headerlink" title="复杂度 引言"></a>复杂度 引言</h1><p>本篇文章是 数据结构与算法 正式内容的第一篇文章。<br>要介绍的也是数据结构与算法中最重要的概念之一：**<code>复杂度</code>**</p>
<p>复杂度，是贯穿整个数据结构与算法学习的一个重要概念。</p>
<p>它是衡量一个算法好坏的重要指标，它包括两个维度：**<code>时间</code><strong>、</strong><code>空间</code>**，被称为 **<code>时间复杂度</code><strong>、</strong><code>空间复杂度</code>**。<br><strong><code>时间复杂度</code></strong> 主要衡量一个算法的运行快慢<br><strong><code>空间复杂度</code></strong> 主要衡量一个算法运行所需要的额外空间</p>
<p>算法的复杂度，一般与需要处理的数据量挂钩，如果数据量为 <code>N</code>，那复杂度就有可能是：<code>N</code> 、 <code>logN</code> 、<code>N*logN</code> 、<code>N^2</code> 等等。</p>
<p>究竟什么是复杂度？</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>上面提到：**<code>时间复杂度</code>** 主要衡量一个算法的运行快慢。<br>但是，这里的 快慢 并不是指 算法运行所需要执行的具体的时间。而是指：<code>算法中的基本操作的执行次数</code>。并且，算法的时间复杂度用一个函数表示.</p>
<p>举个简单的例子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 一个简单的循环</span>
<span class="token keyword">void</span> <span class="token function">Fun1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码，<code>for</code> 循环执行的次数，是根据传入的参数来具体决定的，即循环 <code>n</code> 次。就可以说，这个函数的 时间复杂度是 <code>O(N)</code>。</p>
<p>看起来非常简单？</p>
<p>那么再看一个例子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Fun2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span>  
		<span class="token punctuation">&#123;</span>  
			<span class="token operator">++</span>count<span class="token punctuation">;</span>  
		<span class="token punctuation">&#125;</span>  
	<span class="token punctuation">&#125;</span>  
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> k<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token operator">++</span>count<span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>  
	
	<span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
	<span class="token keyword">while</span> <span class="token punctuation">(</span>M<span class="token operator">--</span><span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token operator">++</span>count<span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数 <code>Fun2</code> 中存在三个循环体，其中一个是嵌套的双重循环<br>那么，这个函数的 时间复杂度 是多少呢？该怎么计算？</p>
<p>逐个分析：</p>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token operator">></span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span>  
<span class="token operator">></span><span class="token punctuation">&#123;</span>  
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token operator">++</span>count<span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span>  
<span class="token operator">></span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个循环是一个循环的嵌套，执行次数是 <code>N*N</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> k<span class="token punctuation">)</span>  
<span class="token operator">></span><span class="token punctuation">&#123;</span>  
<span class="token operator">++</span>count<span class="token punctuation">;</span>  
<span class="token operator">></span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个循环就是一个普通的循环，执行次数是 <code>2*N</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
<span class="token operator">></span><span class="token keyword">while</span> <span class="token punctuation">(</span>M<span class="token operator">--</span><span class="token punctuation">)</span>  
<span class="token operator">></span><span class="token punctuation">&#123;</span>  
<span class="token operator">++</span>count<span class="token punctuation">;</span>  
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个循环是 可以确定次数的循环，每次函数调用执行的次数是一定的，执行次数是 <code>10</code> 次</p>
</blockquote>
<p>结合起来，这个函数的时间复杂度就是 <code>O(N^2 + 2*N + 10)</code><br>但是，事实并不是这样的。<br>这个函数的时间复杂度 其实是 <code>O(N^2)</code><br>为什么？</p>
<p>来进行一个计算：</p>
<ul>
<li><code>N = 10， 执行次数：10*10 + 2*10 + 10 = 130</code></li>
<li><code>N = 100， 执行次数：100*100 + 2*100 + 10 = 10210</code></li>
<li><code>N = 1000， 执行次数：1000*1000 + 2*1000 + 10 = 1002010</code></li>
<li><code>N = 10000， 执行次数：10000*10000 + 2*10000 + 10 = 100020010</code></li>
</ul>
<p>有没有发现什么规律？<br>随着 <code>N</code> 的增大，<code>2*N + 10</code> 在最终执行次数中的 <code>占比越来越小</code> 了，也代表着 其对最终执行次数的 <code>影响越来越小</code> 了<br><code>2*N + 10</code> 在结果中的占比： <code>23%</code> -&gt; <code>2%</code> -&gt; <code>0.2%</code> -&gt; <code>0.02%</code></p>
<p>当 <code>N</code> 足够大的时候，就已经可以忽略 <code>2*N + 10</code> 的影响了，所以只需要计算 <code>N^2</code> 就能够代表函数的执行次数，所以 函数 <code>Fun2</code> 的时间复杂度 其实是 <code>O(N^2)</code>。</p>
<p>这时候计算时间复杂度，就只是计算了大概了执行次数，使用的是<code>大 0 的渐进表示法</code></p>
<h2 id="大-O-的渐进表示法"><a href="#大-O-的渐进表示法" class="headerlink" title="大 O 的渐进表示法"></a>大 O 的渐进表示法</h2><pre><code>大O符号（Big O notation）：是用于描述函数渐进 行为 的数学符号
</code></pre>
<p>用 <code>大O表示法</code> 计算复杂度的方法一般有：</p>
<ol>
<li>基本操作的执行次数中，相加的常数一般用 <code>1</code> 取代<br>即：<code>N^2 + 2*N + 10</code>   —&gt;  <code>N^2 + 2*N + 1</code><br>或： <code>O(100)</code> —&gt; <code>O(1)</code>，即常数的时间复杂度，均计算为 <code>O(1)</code></li>
<li>在常数转后之后的执行次数函数中，取最高次幂项作为时间复杂度，<br>即： <code>O(N^2 + 2*N + 1)</code> —&gt; <code>O(N^2)</code></li>
<li>如果转换后的执行次数函数中，存在 <code>最高次幂项 且 此项不为1</code>，则只保留单个此项作为时间复杂度<code>(即放弃与其相乘的常数)</code><br>即：<code>O(4 * N^2)</code> —&gt; <code>O(N^2)</code></li>
</ol>
<p>即，大O的渐进表示法 <code>去掉了那些对结果影响不大的项</code> ，简洁明了的表示出了时间复杂度。<br>所以 函数<code>Fun2</code> 的时间复杂度为： <code>O(N^2)</code> 忽略了 <code>2*N + 10</code></p>
<h3 id="时间复杂度的最好、最坏、平均情况"><a href="#时间复杂度的最好、最坏、平均情况" class="headerlink" title="时间复杂度的最好、最坏、平均情况"></a>时间复杂度的最好、最坏、平均情况</h3><p>虽然知道了 大O渐进表示法 的计算方法，但是 总有一些算法代码是拥有多种情况的。<br>比如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//查找整型数组中第一个 10 的位置</span>
<span class="token keyword">int</span> <span class="token function">Find_10</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> arrSize<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>arrSize<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>arr <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> i<span class="token punctuation">;</span>	
		<span class="token punctuation">&#125;</span>
		arr<span class="token operator">++</span><span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个函数目的是寻找数组中第一个 <code>10</code> 的位置，但是  第一个 <code>10</code> 有可能出现在 一个数组中的任何位置，甚至不出现在数组中。</p>
<p>可能是 在 <code>arr[0]</code> <code>arr[n - 1]</code> <code>arr[n / 2]</code> ，被查找的数的位置是不定的，所以 这个函数中 <code>基本操作的执行次数也是不定的</code>。</p>
<p>那么这个时候，<code>一个算法的时间复杂度，就用最坏情况下的复杂度来表示</code><br><code>Find_10</code> 这个函数的时间复杂度，实际就是 <code>O(N)</code>。</p>
<blockquote>
<p><code>「PS:计算基本操作的执行次数，结果中的未知数用 N 或 M 代表(只有一个未知数 用 N,两个未知数 用 N 和 M, 多个可以用其他)」</code></p>
</blockquote>
<h2 id="时间复杂度计算举例"><a href="#时间复杂度计算举例" class="headerlink" title="时间复杂度计算举例"></a>时间复杂度计算举例</h2><blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算Func1的时间复杂度？  </span>
<span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> N <span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token operator">++</span>count<span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
	<span class="token keyword">while</span> <span class="token punctuation">(</span>M<span class="token operator">--</span><span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token operator">++</span>count<span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>  
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此函数，通过分析<br>拥有两个循环体，一个循环 <code>2*N</code> 次，另一个循环 <code>10</code> 次<br>按照 大O 渐进表示法，时间复杂度为 <code>O(N)</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算Func2的时间复杂度？  </span>
<span class="token keyword">void</span> <span class="token function">Func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token operator">++</span>count<span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>  
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> <span class="token operator">++</span> k<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token operator">++</span>count<span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>  
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此函数，通过分析<br>拥有两个循环体，一个循环 <code>M</code> 次，另一个循环 <code>N</code> 次<br>按照 大O 渐进表示法，时间复杂度为 <code>O(M + N)</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算Func3的时间复杂度？  </span>
<span class="token keyword">void</span> <span class="token function">Func3</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token operator">++</span>count<span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>  
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此函数，通过分析<br>有一个循环体，但是循环体循环次数与传入参数无关，固定循环 <code>100</code> 次<br>按照 大O 渐进表示法，时间复杂度为 <code>O(1)</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算BubbleSort的时间复杂度？  </span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> end <span class="token operator">=</span> n<span class="token punctuation">;</span> end <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>end<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token keyword">int</span> exchange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  
		<span class="token punctuation">&#123;</span>  
			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  
			<span class="token punctuation">&#123;</span>  
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
				exchange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
			<span class="token punctuation">&#125;</span>  
		<span class="token punctuation">&#125;</span>  
		<span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
			<span class="token keyword">break</span><span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此函数为<code>冒泡排序（排升序）</code><br>需要分情况分析：<br>最好的情况是：除了第一位其他都已位升序，则只需要循环 <code>N</code>  次，即 <code>将第一位数据冒泡至最后一位</code><br>最坏的情况是：数据按照降序排列，则每一个数据都要进行排序，计算执行次数的结果为：<code>(N*(N+1)/2</code> 次<br>按照 大O 渐进表示法，取最坏的情况时间复杂度为 <code>O(N^2)</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算BinarySearch的时间复杂度？  </span>
<span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  

	<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
	<span class="token keyword">int</span> end <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token keyword">int</span> mid <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end<span class="token operator">-</span>begin<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span>  
			begin <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">)</span>  
			end <span class="token operator">=</span> mid<span class="token punctuation">;</span>  
		<span class="token keyword">else</span>  
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>  

	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此函数为<code>二分查找</code>，<code>(被查找的数据必须是有序的)</code><br>同样需要分情况分析：<br>最好的情况：<code>指定数据在数组中间位置，只需要执行一次</code>，即第一次查找就查找到指定数据<br>最坏的情况：</p>
<blockquote>
<p>二分查找的原理：<code>因为使用二分查找的数据必须是有序的，所以可以通过缩小查找范围来进行查找</code><br>二分查找每次查找一次，<code>下一次查找的范围会缩小为当前范围的一半</code><br>只需要一张动图就可解释：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/BinarySearch.gif"><br>可以看出，每次查找之后，下一次需要查找的元素只剩下一半，所以最坏的情况其实是 需要查找：<code>log N</code>次<br><code>复杂度中，log N即为 以2为底N的对数</code></p>
</blockquote>
<p>所以按照 大O 渐进表示法，取最坏的情况时间复杂度为 <code>O(log N)</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算阶乘递归Fac的时间复杂度？  </span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fac</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> N<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> N<span class="token punctuation">)</span>  
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  

	<span class="token keyword">return</span> <span class="token function">Fac</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>N<span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此函数为 <code>递归求阶乘</code><br>递归求阶乘，通过计算可以算出，求<code>N的阶乘</code> 则函数调用了 <code>N</code>次<br>所以按照 大O 渐进表示法，时间复杂度为 <code>O(N)</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算斐波那契递归Fib的时间复杂度</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fib</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> N<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>  
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  

	<span class="token keyword">return</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此函数为 <code>递归求斐波那契数列</code><br>递归求斐波那契数列，一个简单的递归分析图：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Fib_5.jpg"><br>发现正常调用函数，会再发生两次递归，所以应该是 <code>2^N</code><br>但是因为当 <code>N &lt; 3</code> 会返回 <code>1</code>，不再递归，所以应该是 <code>2^N - x</code> <code>(不容易计算所以用 x 表示)</code>，但是无论怎样，相减的常数因该是对<code>2^N</code> 造不成多大影响的<br>所以按照 大O 渐进表示法，时间复杂度为 <code>O(2^N)</code></p>
</blockquote>
<hr>
<p>练习结束，感觉如何？？</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p><strong><code>空间复杂度</code></strong> 主要衡量一个算法运行所需要的额外空间<br>这里提到一个词：**<code>额外空间</code>**</p>
<p>为什么是 <code>额外空间</code> ？<br>因为，<code>函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，在函数运行前就已经确定了一部分空间，这些空间的占用不能由算法本身决定</code><br>所以，空间复杂度主要通过 <code>函数在运行时候申请的额外空间</code> 来确定。</p>
<blockquote>
<p>这里推荐一篇 详细又简单 的 函数栈帧 的好文章：<br><a href="https://dxyt-july.cn/posts/Function-Stack-Frame.html">【程序员的自我修养】[动态图文] 超详解函数栈帧</a><br><a href="https://dxyt-july.cn/posts/Function-Stack-Frame.html" target="-blank" title="【程序员的自我修养】[动态图文] 超详解函数栈帧" ><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Laugh.jpg"></p>
</blockquote>
<blockquote>
<pre><code>    在函数内使用动态开辟内存的函数，以及创建柔性数组等操作，就会增加函数的额外空间哦
</code></pre>
</blockquote>
<p><code>空间复杂度</code> 和 <code>时间复杂度</code> 的表示方法一样，都用 大O渐进表示法。</p>
<h2 id="空间复杂度的计算举例"><a href="#空间复杂度的计算举例" class="headerlink" title="空间复杂度的计算举例"></a>空间复杂度的计算举例</h2><p>依然举几个例子：</p>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算BubbleSort的空间复杂度？  </span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> end <span class="token operator">=</span> n<span class="token punctuation">;</span> end <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>end<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		<span class="token keyword">int</span> exchange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  
		<span class="token punctuation">&#123;</span>  
			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  
			<span class="token punctuation">&#123;</span>  
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
				exchange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
			<span class="token punctuation">&#125;</span>  
		<span class="token punctuation">&#125;</span>  
		<span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
			<span class="token keyword">break</span><span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分析代码可以看出，冒泡排序额外使用的空间并没有与 <code>N</code> 发生关联。使用了常量个额外空间<br>所以 按照 大O 渐进表示法，空间复杂度为 <code>O(1)</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算Fibonacci的空间复杂度？  </span>
<span class="token comment">// 返回斐波那契数列的前n项  </span>
<span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  
	<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span> fibArray <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	fibArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
	fibArray<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  
	<span class="token punctuation">&#123;</span>  
		fibArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> fibArray<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> fibArray <span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
	<span class="token punctuation">&#125;</span>  

	<span class="token keyword">return</span> fibArray<span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是使用 <code>数组实现的计算斐波那契数列的 前N 项</code><br>分析代码可以看出，这段代码 使用 <code>malloc</code> 函数开辟了 <code>n+1</code> 个 <code>long long</code>类型的空间，即额外使用的空间与 <code>N</code> 1:1相关<br>所以 按照 大O 渐进表示法，空间复杂度为 <code>O(N)</code></p>
</blockquote>
<blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算阶乘递归Fac的空间复杂度？  </span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fac</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> N<span class="token punctuation">)</span>  
<span class="token punctuation">&#123;</span>  
	<span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  

	<span class="token keyword">return</span> <span class="token function">Fac</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>N<span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>递归求N的阶乘</code><br>分析代码可以看出，代码执行需要递归 <code>N</code> 次，且每次递归都需要开辟函数栈帧，<code>每次函数栈帧开辟都会消耗常量个空间</code>，所以是 <code>常量 * N</code><br>按照 大O 渐进表示法，空间复杂度为 <code>O(N)</code></p>
</blockquote>
<hr>
<p>以上内容就是 关于 <strong><code>时间复杂度</code></strong> 和 <strong><code>空间复杂度</code></strong>  的介绍。<br>复杂度需要进行学习的已经介绍的差不多了。<br>但是，需要注意的是<br><code>其实大部分的代码，时间、空间复杂度是不容易直接看出来的，一定要执行分析。对存在循环体的代码，也不要直接简单粗暴的去数循环体执行的次数，因为循环并不一定是都需要执行的。一定要分析。</code></p>
<hr>
<h1 id="复杂度对比"><a href="#复杂度对比" class="headerlink" title="复杂度对比"></a>复杂度对比</h1><p>常见的复杂度都有什么呢？</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Com_com.jpg"><br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Com_FUN.jpg"></p>
<hr>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>数据结构与算法关于复杂度的部分到这里就介绍完了。<br>本篇文章是对 <code>数据结构与算法</code> 这片<code>神秘海域</code>的初探索。<br>同样也是 <code>向更深海域探索的重要基石</code></p>
<hr>
<p>感谢阅读！<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/fangun_dog.gif"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/fangun_dog.gif"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/fangun_dog.gif"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构与算法</tag>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么防止云服务图床被爬虫爬？给自己的图床添加白名单~</title>
    <url>/posts/Figur-Bed-Whitelist.html</url>
    <content><![CDATA[<h1 id="原由"><a href="#原由" class="headerlink" title="原由"></a>原由</h1><p>大家好啊！我是七月<br>上个月发生了一件让许多人破防的一件事：<code>Gitee 图床炸了</code></p>
<span id="more"></span>

<p>在 <code>Gitee</code> 上建立的图床里的图片全都变成了 <code>Gitee</code> 的图标：<br><img src="https://img-blog.csdnimg.cn/3ffc2687b14840ef87c27e14844d9cfb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiD5pyISnVseS4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>
<p>这波事故过后一定有许多小伙伴也不敢再在 <code>Gitee</code> 创建图床，免得把再自己给整破防了。<br>肯定有许多小伙伴转到了 <code>阿里云</code> 等云平台服务重新建立了自己的图床。<br>但是在 云平台服务建立图床 <code>不是免费的</code>，无论是空间还是流量都不是免费的。<br>所以，对自己图床访问的限制也就变得尤为重要。<br> <strong><code>不然自己的云服务就可能被爬虫摧残！！</code></strong> <code>(我已经有了惨痛的教训,都是金钱的教训)</code><br>下面就来具体说明一下，<code>如何给自己的图床设置白名单</code>，来阻隔各路爬虫的访问。</p>
<hr>
<h1 id="给图床设置白名单"><a href="#给图床设置白名单" class="headerlink" title="给图床设置白名单"></a>给图床设置白名单</h1><p> 这里以 <code>阿里云</code> 为例 <code>( 阿里云手机暂不支持操作，或者是我没找到如何修改 )</code></p>
<p>首先，在自己的 <code>OSS管理控制台</code> 进入<code>需要设立白名单的Bucket</code><br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/OSS_1.png" alt="请添加图片描述"><br>然后再左边列表选择 <code>权限管理-&gt;防盗链</code><br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/OSS_2.png"></p>
<p>然后找到 <code>开启防盗链</code>，并打开<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/OSS_3.png"></p>
<p>打开后，在 <code>Referer</code> 表里，添加 <code>白名单域名</code> 或 <code>ip</code>  就好了</p>
<h1 id="白名单需要添加什么"><a href="#白名单需要添加什么" class="headerlink" title="白名单需要添加什么"></a>白名单需要添加什么</h1><p><code>白名单(防盗链)</code> 中，添加一般 <code>需要访问图床图片</code> 的 <code>网址</code> 和 <code>ip</code></p>
<p>比如，我们在 <code>C站</code> 写博客需要访问图床外链，就把 <code>C站的域名</code> 添加进去：<code>*.csdn.net</code></p>
<p>或者，需要在 <code>阿里云OSS</code> 预览图片：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/cover_OSS.png"></p>
<p>也需要将 <code>阿里云</code> 的域名添加进去，如果不添加就会变成这样：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/cover_OSS_2.png"></p>
<p>将 <code>需要访问图床图片的网站域名</code> 添加进去之后，指定网站就可以访问获取图片了 !</p>
<p>这里我添加了需要访问图片的域名：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Referer_yuming.png"><br>添加域名的方式，阿里云有给手册 ：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/For_star.png"></p>
<p>添加完成后，就可以<code>防止白名单外的网站访问图床内的图片</code>，就可以 <code>防止爬虫访问导致流量疯狂外流</code>。</p>
<h2 id="添加-ip-建议"><a href="#添加-ip-建议" class="headerlink" title="添加 ip 建议"></a>添加 ip 建议</h2><p>添加完网站域名，我还推荐 <code>将自己常用网络的ip地址</code> 添加至白名单。否则本地访问 图床图片时 会被拒绝导致访问失败。</p>
<p>考虑到有些小伙伴可能不知道自己的 网络 <code>ip</code>，这里提供一下查询方法<code>(Windows平台)</code>：</p>
<blockquote>
<ol>
<li>使用 <code>CMD</code> 指令查看：<br> 先打开 <code>CMD</code> 或 <code>Terminal(Win11)</code>：<br> <code>CMD</code>：可以 <code>Win + R</code> 组合键唤出  <code>运行</code>，然后输入 <code>CMD</code> 运行就可以<br> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/run_CMD.png"></li>
</ol>
</blockquote>
<blockquote>
<p> <code>Terminal(Win11)</code> ：右键 <code>开始按钮</code> 选择 <code>终端(Terminal)</code> 就可以<br> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/run_Terminal.png"></p>
</blockquote>
<blockquote>
<p> 然后在弹出的界面输入 <code>ipconfig /all</code> 回车<br> 就可以找到 <code>当前网络 ip</code>：<br> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/now_ip_adress.png"></p>
<ol start="2">
<li>开始界面打开 <code>设置</code>，并打开 <code>网络与Internet</code>，找到 <code>属性</code> 点击就可以看到 <code>当前网络ip</code>：<br> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/now_ip_adress2.png"></li>
</ol>
</blockquote>
<p>找到自己的 <code>网络 ip</code> 然后添加到 <code>阿里云OSS</code> <code>防盗链(白名单)</code> 里就 OK 啦！ </p>
<hr>
<p>OK 本篇文章到这里就结束了！</p>
<p><code>祝以后的我们的无论使用什么做图床，都不会再挂！！</code></p>
]]></content>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>File-Operations</title>
    <url>/posts/File-Operations.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Function-Stack-Frame</title>
    <url>/posts/Function-Stack-Frame.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Single-List</title>
    <url>/posts/Single-List.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Structure</title>
    <url>/posts/Structure.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
