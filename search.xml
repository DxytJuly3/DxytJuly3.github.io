<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【程序员的自我修养】[动态图文] 理解编译到链接的过程 [编译与链接一]</title>
    <url>/posts/Compile-And-Link.html</url>
    <content><![CDATA[<h1 id="程序的编译及链接"><a class="markdownIt-Anchor" href="#程序的编译及链接"></a> 程序的编译及链接</h1>
<p>在学习C语言的过程中，每一个 <code>.c</code> 文件都会经过 <code>编译链接</code> 等 <code>预处理</code> 操作才能成为一个 <code>.exe</code> 的可执行文件的</p>
<p>这些 <code>预处理</code> 过程到底是如何进行的，就是本篇文章的内容</p>
<span id="more"></span>
<h2 id="一-程序的翻译环境和执行环境"><a class="markdownIt-Anchor" href="#一-程序的翻译环境和执行环境"></a> 一、程序的翻译环境和执行环境</h2>
<p>一般写出的 <code>.c</code> 后缀的 源代码文件，是不能直接执行的。<br />
类似 <code>.c</code> 的源代码文件要变成  类似 <code>.exe</code> 后缀的 可执行文件，再到可执行[[程序的运行]]实现 是要经过两个环境的：<code>翻译环境</code> <code>执行环境</code></p>
<p>大致的过程是：</p>
<ol>
<li>一个源代码文件，由翻译环境翻译为 计算机能够直接看懂的 二进制指令（机器指令），即生成可执行程序： 类似 <code>.exe</code> 后缀的文件（不同系统环境下的可执行程序的后缀是不同的）</li>
<li>可执行[[程序的运行]]实现，就需要 通过运行环境 来实现</li>
</ol>
<p>即：</p>
<blockquote>
<p>在ANSI C的任何一种实现中，存在两个不同的环境。<br />
第1种是 <code>翻译环境</code>，在这个环境中源代码被转换为可执行的机器指令。<br />
第2种是 <code>执行环境</code>，它用于实际执行代码</p>
</blockquote>
<h3 id="1-1-翻译环境"><a class="markdownIt-Anchor" href="#1-1-翻译环境"></a> 1. 1 翻译环境</h3>
<p>翻译环境可以简单的分为两个过程： <code>编译</code> 和 <code>链接</code><br />
编译的作用是，将一个项目中的每一个源代码文件(<code>.c</code> 后缀等)，都单独处理为 对应的目标文件(VS编译器 环境下<code>.obj</code> 后缀，GCC编译器 环境下 <code>.o</code>后缀)</p>
<p>而链接，则是将编译生成的 <code>.obj</code> 目标文件与所其涉及到的静态库，一起进行链接，最终生成 <code>.exe</code> 后缀的可执行文件</p>
<blockquote>
<p>📌<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/%E4%BC%98%E5%8C%96_%E7%BC%96%E8%AF%91_%E9%93%BE%E6%8E%A5.gif" alt="优化_编译_链接" /></p>
<p>在这一整个过程中，<code>编译器</code>来完成编译操作，<code>链接器</code>来完成链接操作</p>
</blockquote>
<p>在编译链接的过程中，除了源文件(<code>.c</code>后缀)和目标文件(<code>.obj</code>或<code>o</code>后缀)，还提到了一个名词：<code>静态库</code> 也可以被称作 <code>静态链接库</code>。</p>
<blockquote>
<p>📌<br />
<code>静态库链接库</code>是什么？</p>
<p>编写C语言代码使用的一些函数，例如:<br />
<code>printf</code> <code>scanf</code> 等等，<br />
这些函数，并不属于编写者所自定义的函数。这些函数是由 C 语言默认提供的。这些由 C 语言默认提供的函数，一般都存放在各自的库中：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/printf%E9%9D%99%E6%80%81%E5%BA%93.png" alt="printf" /><br />
像以上 <code>LIBC.LIB</code> 、 <code>LIBCMT.LIB</code> 、<code>MSVCRT.LIB</code> 都属于静态库，<code>printf</code> 函数就存在于这三个 <code>静态链接库</code> 中</p>
</blockquote>
<p>如果在编写的 源代码文件 中，使用到了存在于某些 <code>静态链接库里的库函数</code><br />
那么在链接的时候，就会将 <code>所使用函数的静态库</code> 与 <code>编译生成的目标文件</code> 一起链接起来，以致于可执行程序可以正常执行。</p>
<p>以上的编译过程可以细分为三个过程：预编译、编译、汇编</p>
<h3 id="12-翻译详解"><a class="markdownIt-Anchor" href="#12-翻译详解"></a> 1.2 翻译详解</h3>
<p>上面了解到，由源代码到可执行程序的过程是要经过 <code>翻译环境</code> 的一系列操作的，翻译环境大方面分为 <code>编译</code> <code>链接</code> 两个大过程，而编译又可以细分为：预编译([[预处理]])、编译、汇编 三个详细过程。<br />
下面是编译的三个详细过程的详解：</p>
<blockquote>
<pre><code>         以下 均为 Linux平台-GCC编译环境下 的演示效果
</code></pre>
</blockquote>
<h4 id="121-预编译"><a class="markdownIt-Anchor" href="#121-预编译"></a> 1.2.1 预编译</h4>
<p>预编译是干什么的？<br />
预编译，一般进行三项操作：</p>
<ol>
<li>对 头文件的包含、展开</li>
<li>对 注释的删除</li>
<li>对 <code>#define</code> 所宏定义符号的转换</li>
</ol>
<p>干巴巴的只用文字表述，其实没有办法简单直观的理解这三项操作，所以用图片来演示：</p>
<p>对三项操作一 一进行展示：</p>
<blockquote>
<p>📌 对头文件的包含、展开<br />
Linux 环境下编写简单的一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>        <span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST.png" alt="Linux-test" /><br />
然后用 GCC 编译器对 test.c 文件进行[[预处理]]，并将[[预处理]]后的文件信息输出至 test.i 文件中：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-E.png" alt="GCC -E" /></p>
<blockquote>
<p>✔️小知识：<br />
<code>gcc -E (源代码文件) 或 gcc (源代码文件) -E</code> 对源代码进行预编译<br />
<code>gcc -E (源代码文件) -o (指定预处理文件)或 gcc (源代码文件) -E -o (指定预处理文件)</code> 对源代码进行[[预处理]]并输出至指定文件内</p>
</blockquote>
<p>可以看到 路径下生成 test.i 文件，最后一部分内容为：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-i.png" alt="TEST-i" /><br />
除了最后的几行代码，以上并不是原文件中的代码，并且 原代码文件中<code>#include &lt;stdio.h&gt;</code> 对头文件的包含消失不见<br />
以上的内容与 stdio.h 部分内容做对比：<br />
<code>stdio.h</code> 部分内容：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-STDIO.png" alt="stdio.h" /><br />
很容易发现，两文件中关键代码是相同的<br />
所以可以肯定，<code>预编译过程中，编译器对源代码进行了 头文件的包含、展开的操作</code></p>
</blockquote>
<blockquote>
<p>📌 对注释的删除<br />
在上面两个文件做对比的时候，细心观察可以发现，两个文件所包含的相同的头文件的代码行数是不相同的<br />
再一对比，可以看出 <code>test.i</code>  文件中并没有蓝色的注释部分<br />
说明预编译，对源代码也进行了 删除注释 的操作<br />
还有一个更直观的 展示方法（使用以下代码进行预编译操作）(可以直接再 <code>test.c</code> 文件中添加)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是头文件的包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这是程序主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 这是一个 printf 函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这是主函数的返回操作</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-Annotation.png" alt="TEST-Annotation" /><br />
对以上代码进行预编译操作，并查看预编译后的文件内容：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-VIM-TEST-i-Annotation.png" alt="READ-TEST.i" /><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-E-Annotation.png" alt="GCC-PRE-E-Annotation" /><br />
同样可以看出，预编译后的代码中，注释内容被删除了，也可以说是被空格替换掉了<br />
所以，<code>预编译过程中，编译器源代码进行了 删除注释 的操作</code></p>
</blockquote>
<blockquote>
<p>📌 对 #define 宏定义符号的替换<br />
还是不同的代码，同样的操作<br />
使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 3 THREE  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 666 CSDN</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = THREE;</span><br><span class="line">	<span class="type">int</span> y = CSDN;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x * y);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-Macro.png" alt="TEST-Macro" /><br />
预编译处理：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-E-Macro.png" alt="GCC-PRE-E-Macro" /><br />
<code>test.i</code> 部分内容:<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-i-Macro-READ.png" alt="TEST-i-Macro-READ" /></p>
<p>源代码中的 两句宏定义 语句被删除，函数中使用的宏定义符号 被替换为 原本的数值</p>
<p>可以说明，<code>预编译过程中，编译器对源代码进行了 替换宏定义符号 的操作</code></p>
</blockquote>
<p>以上的三种示例，可以说明预编译过程 一般是对源代码进行的一些 <code>文本的删除、替换、文件文本的包含、展开等</code>。<br />
所以可以说，<code>预编译 一般是对源代码 进行一系列的文本操作</code></p>
<hr />
<h4 id="122-编译"><a class="markdownIt-Anchor" href="#122-编译"></a> 1.2.2 编译</h4>
<p>经过预编译后的源代码文件，已经除去了许多对计算机来说没有用的信息(比如 注释，注释一般是写给操作者看的，计算机不需要注释)</p>
<p><code>预编译</code> 的作用一般是对源代码进行 <code>文本操作</code> ，那么 <code>编译</code> 的具体作用是什么呢？</p>
<p>我们通过对上面某个已经 经过预编译的文件 进行编译:</p>
<blockquote>
<p>📌<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-S.png" alt="GCC-PRE-S" /></p>
<blockquote>
<p>✔️小知识：<br />
<code>gcc -S (经过预编译的文件) 或 gcc (经过预编译的文件) -S</code><br />
可以对已经经过预编译的文件进行编译，自动输出到 文件对应的以 <code>.s</code> 为后缀的文件</p>
</blockquote>
<p>查看 <code>test.s</code> 的具体内容：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-VIM-TEST-S.png" alt="VIM-TEST-S" /></p>
<p>查看 <code>test.s</code> 的内容不难发现，它的内容都是 <code>汇编代码</code></p>
<p>所以，预编译之后的编译操作，其实是将 <code>经过预编译的代码</code>  转变为 <code>对应的汇编代码指令</code></p>
<p>编译的作用就是，把 <code>C语言代码</code> 转变成 <code>相应的汇编代码</code></p>
<blockquote>
<p>编译这个过程的细节一般还会分为:</p>
<ol>
<li><code>语法分析</code></li>
<li><code>词法分析</code></li>
<li><code>语义分析</code></li>
<li><code>符号汇总</code></li>
</ol>
</blockquote>
<p>更加细节的内容不在这里赘述。(以后有机会再详细介绍一下)</p>
</blockquote>
<h4 id="123-汇编"><a class="markdownIt-Anchor" href="#123-汇编"></a> 1.2.3 汇编</h4>
<p>汇编 是对 汇编代码 进行的操作，汇编的作用是将 汇编代码 转换成 计算机可以直接识别的 <code>机器指令</code> 即，<code>二进制指令</code>。</p>
<p>对 <code>test.s</code> 文件进行汇编操作：</p>
<blockquote>
<p>📌<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-GCC-PRE-C.png" alt="GCC-PRE-C" /></p>
<blockquote>
<p>✔️小知识：<br />
<code>gcc -c (经过预编译的文件) 或 gcc (经过预编译的文件) -c</code><br />
<code>(注意此处 -c 中，c 为小写)</code><br />
可以对汇编代码文件进行汇编操作，将生成的二进制指令 输出到对应的以 <code>.o</code> 为后缀的文件中<br />
<code>.o</code> 后缀的文件，就是 <code>GCC环境</code> 生成的目标文件</p>
</blockquote>
<p>查看 <code>.o</code> 目标文件：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-TEST-O.png" alt="TEST-O" /><br />
<code>vim</code> 打开，可以看出 目标文件几乎都是乱码。其实只是计算机可以直接识别的二进制的指令。</p>
<p>所以，<code>汇编操作</code> 是将 <code>汇编代码</code> 转换为 <code>机器指令（二进制指令）</code>。</p>
</blockquote>
<hr />
<p>以上三段过程，是翻译环境中 编译的整个过程，而翻译最重要的环节之一，还有：链接：</p>
<hr />
<h4 id="124-链接-及-结果"><a class="markdownIt-Anchor" href="#124-链接-及-结果"></a> 1.2.4 链接 及 结果</h4>
<p>链接，是对项目中所有的目标文件进行链接的，如果想要展示出链接的作用，可以编写多个 <code>.c</code> 文件进行编译，再将所有的 <code>.o</code> 文件 进行链接。</p>
<blockquote>
<p>📌</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// add.c</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">ADD</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> x + y;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// sub.c</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">SUB</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> x - y;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// test.c</span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ADD</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&gt;<span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">SUB</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> sum = ADD(x, y);</span><br><span class="line"><span class="type">int</span> dev = SUB(x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dev = %d\n&quot;</span>, dev);</span><br><span class="line">       </span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>vim</code>：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-LINK-ADD-C.png" alt="add.c" /><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-LINK-SUB-C.png" alt="sub.c" /><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-LINK-TEST-C.png" alt="test.c" /></p>
<p>然后，分别对 <code>add.c</code> 、<code>sub.c</code>、 <code>test.c</code> 三个<code>.c</code> 文件，预编译、编译、汇编：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-PROJECT-E-S-c.png" alt="PROJECT-E-S-c" /><br />
最终生成对应的：<code>add.o</code> 、<code>sub.o</code> 、<code>test.o</code></p>
<p>最后对 <code>所有的目标文件</code> 进行链接<br />
<code>（用户不用主动在意静态库，链接器会自动链接）</code>：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-PROJECT-LINK.png" alt="PROJECT-LINK" /></p>
<blockquote>
<p>✔️小知识：<br />
<code>gcc (所有的目标文件)</code> 即可将所有目标文件链接在一起，生成可执行程序。<br />
后接 <code>-o (指定程序名)</code> <code>gcc (所有的目标文件) -o (指定程序名)</code><br />
可生成指定文件名的可执行文件</p>
</blockquote>
<p>为了做对比，直接对 <code>add.c</code> 、<code>sub.c</code> 、<code>test.c</code> 进行编译链接<br />
方便进行对比：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-PROJECT-GCC.png" alt="PROJECT-GCC" /><br />
直接编译链接，不指定文件名，生成  <code>a.out</code> 可执行程序</p>
<p>分别运行 <code>test</code> 、<code>a.out</code></p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/pre-Linux-PROJECT-RUN.png" alt="PROJECT-RUN" /></p>
<p><code>test</code> 、<code>a.out</code> 两程序运行结果相同，说明 拆解过程的编译链接 及 直接的编译链接 结果是一样的</p>
<p>可以说明，一个项目 在翻译环境中的整个过程确实为：</p>
<ol>
<li>编译<br />
a. 预编译 <code>(删除原代码中的注释、对头文件进行包含.展开、对宏符号进行转换 等)</code><br />
b. 编译 <code>(将 C 语言代码文件 转换为 对应的汇编代码文件)</code><br />
c. 汇编 <code>(将 汇编代码文件 转换为 对应的机器指令文件（目标文件）)</code></li>
<li>链接 <code>(将 所有目标文件 及 静态库 链接 生成可执行文件)</code></li>
</ol>
<p>那么，项目文件从 <code>.c</code> 到 可执行文件的过程 可以简单的详细为：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/Pre-More.gif" alt="Pre-More" /></p>
</blockquote>
]]></content>
      <categories>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>【神秘海域】[动图] 数据结构与算法初探：复杂度详解分析 「附代码」</title>
    <url>/posts/DS-Complexity.html</url>
    <content><![CDATA[<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/DS_Cover_Com.jpg" alt="" /></p>
<hr />
<h1 id="复杂度-引言"><a class="markdownIt-Anchor" href="#复杂度-引言"></a> 复杂度 引言</h1>
<p>本篇文章是 数据结构与算法 正式内容的第一篇文章。<br />
要介绍的也是数据结构与算法中最重要的概念之一：<strong><code>复杂度</code></strong></p>
<p>复杂度，是贯穿整个数据结构与算法学习的一个重要概念。</p>
<span id="more"></span>
<p>它是衡量一个算法好坏的重要指标，它包括两个维度：<strong><code>时间</code></strong>、<strong><code>空间</code></strong>，被称为 <strong><code>时间复杂度</code></strong>、<strong><code>空间复杂度</code></strong>。<br />
<strong><code>时间复杂度</code></strong> 主要衡量一个算法的运行快慢<br />
<strong><code>空间复杂度</code></strong> 主要衡量一个算法运行所需要的额外空间</p>
<p>算法的复杂度，一般与需要处理的数据量挂钩，如果数据量为 <code>N</code>，那复杂度就有可能是：<code>N</code> 、 <code>logN</code> 、<code>N*logN</code> 、<code>N^2</code> 等等。</p>
<p>究竟什么是复杂度？</p>
<h1 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h1>
<p>上面提到：<strong><code>时间复杂度</code></strong> 主要衡量一个算法的运行快慢。<br />
但是，这里的 快慢 并不是指 算法运行所需要执行的具体的时间。而是指：<code>算法中的基本操作的执行次数</code>。并且，算法的时间复杂度用一个函数表示.</p>
<p>举个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个简单的循环</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun1</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，<code>for</code> 循环执行的次数，是根据传入的参数来具体决定的，即循环 <code>n</code> 次。就可以说，这个函数的 时间复杂度是 <code>O(N)</code>。</p>
<p>看起来非常简单？</p>
<p>那么再看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Fun2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N ; ++ j)  </span><br><span class="line">		&#123;  </span><br><span class="line">			++count;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * N ; ++ k)  </span><br><span class="line">	&#123;  </span><br><span class="line">		++count;  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> M = <span class="number">10</span>;  </span><br><span class="line">	<span class="keyword">while</span> (M--)  </span><br><span class="line">	&#123;  </span><br><span class="line">		++count;  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 <code>Fun2</code> 中存在三个循环体，其中一个是嵌套的双重循环<br />
那么，这个函数的 时间复杂度 是多少呢？该怎么计算？</p>
<p>逐个分析：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)  </span><br><span class="line">&gt;&#123;  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N ; ++ j)  </span><br><span class="line">&#123;  </span><br><span class="line">	++count;  </span><br><span class="line">&#125;  </span><br><span class="line">&gt;&#125;  </span><br></pre></td></tr></table></figure>
<p>这个循环是一个循环的嵌套，执行次数是 <code>N*N</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * N ; ++ k)  </span><br><span class="line">&gt;&#123;  </span><br><span class="line">++count;  </span><br><span class="line">&gt;&#125;  </span><br></pre></td></tr></table></figure>
<p>这个循环就是一个普通的循环，执行次数是 <code>2*N</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> M = <span class="number">10</span>;  </span><br><span class="line">&gt;<span class="keyword">while</span> (M--)  </span><br><span class="line">&gt;&#123;  </span><br><span class="line">++count;  </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环是 可以确定次数的循环，每次函数调用执行的次数是一定的，执行次数是 <code>10</code> 次</p>
</blockquote>
<p>结合起来，这个函数的时间复杂度就是 <code>O(N^2 + 2*N + 10)</code><br />
但是，事实并不是这样的。<br />
这个函数的时间复杂度 其实是 <code>O(N^2)</code><br />
为什么？</p>
<p>来进行一个计算：</p>
<ul>
<li><code>N = 10， 执行次数：10*10 + 2*10 + 10 = 130</code></li>
<li><code>N = 100， 执行次数：100*100 + 2*100 + 10 = 10210</code></li>
<li><code>N = 1000， 执行次数：1000*1000 + 2*1000 + 10 = 1002010</code></li>
<li><code>N = 10000， 执行次数：10000*10000 + 2*10000 + 10 = 100020010</code></li>
</ul>
<p>有没有发现什么规律？<br />
随着 <code>N</code> 的增大，<code>2*N + 10</code> 在最终执行次数中的 <code>占比越来越小</code> 了，也代表着 其对最终执行次数的 <code>影响越来越小</code> 了<br />
<code>2*N + 10</code> 在结果中的占比： <code>23%</code> -&gt; <code>2%</code> -&gt; <code>0.2%</code> -&gt; <code>0.02%</code></p>
<p>当 <code>N</code> 足够大的时候，就已经可以忽略 <code>2*N + 10</code> 的影响了，所以只需要计算 <code>N^2</code> 就能够代表函数的执行次数，所以 函数 <code>Fun2</code> 的时间复杂度 其实是 <code>O(N^2)</code>。</p>
<p>这时候计算时间复杂度，就只是计算了大概了执行次数，使用的是<code>大 0 的渐进表示法</code></p>
<h2 id="大-o-的渐进表示法"><a class="markdownIt-Anchor" href="#大-o-的渐进表示法"></a> 大 O 的渐进表示法</h2>
<pre><code>大O符号（Big O notation）：是用于描述函数渐进 行为 的数学符号
</code></pre>
<p>用 <code>大O表示法</code> 计算复杂度的方法一般有：</p>
<ol>
<li>基本操作的执行次数中，相加的常数一般用 <code>1</code> 取代<br />
即：<code>N^2 + 2*N + 10</code>   —&gt;  <code>N^2 + 2*N + 1</code><br />
或： <code>O(100)</code> —&gt; <code>O(1)</code>，即常数的时间复杂度，均计算为 <code>O(1)</code></li>
<li>在常数转后之后的执行次数函数中，取最高次幂项作为时间复杂度，<br />
即： <code>O(N^2 + 2*N + 1)</code> —&gt; <code>O(N^2)</code></li>
<li>如果转换后的执行次数函数中，存在 <code>最高次幂项 且 此项不为1</code>，则只保留单个此项作为时间复杂度<code>(即放弃与其相乘的常数)</code><br />
即：<code>O(4 * N^2)</code> —&gt; <code>O(N^2)</code></li>
</ol>
<p>即，大O的渐进表示法 <code>去掉了那些对结果影响不大的项</code> ，简洁明了的表示出了时间复杂度。<br />
所以 函数<code>Fun2</code> 的时间复杂度为： <code>O(N^2)</code> 忽略了 <code>2*N + 10</code></p>
<h3 id="时间复杂度的最好-最坏-平均情况"><a class="markdownIt-Anchor" href="#时间复杂度的最好-最坏-平均情况"></a> 时间复杂度的最好、最坏、平均情况</h3>
<p>虽然知道了 大O渐进表示法 的计算方法，但是 总有一些算法代码是拥有多种情况的。<br />
比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找整型数组中第一个 10 的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find_10</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(arrSize--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*arr == <span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;	</span><br><span class="line">		&#125;</span><br><span class="line">		arr++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数目的是寻找数组中第一个 <code>10</code> 的位置，但是  第一个 <code>10</code> 有可能出现在 一个数组中的任何位置，甚至不出现在数组中。</p>
<p>可能是 在 <code>arr[0]</code> <code>arr[n - 1]</code> <code>arr[n / 2]</code> ，被查找的数的位置是不定的，所以 这个函数中 <code>基本操作的执行次数也是不定的</code>。</p>
<p>那么这个时候，<code>一个算法的时间复杂度，就用最坏情况下的复杂度来表示</code><br />
<code>Find_10</code> 这个函数的时间复杂度，实际就是 <code>O(N)</code>。</p>
<blockquote>
<p><code>「PS:计算基本操作的执行次数，结果中的未知数用 N 或 M 代表(只有一个未知数 用 N,两个未知数 用 N 和 M, 多个可以用其他)」</code></p>
</blockquote>
<h2 id="时间复杂度计算举例"><a class="markdownIt-Anchor" href="#时间复杂度计算举例"></a> 时间复杂度计算举例</h2>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算Func1的时间复杂度？  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func1</span><span class="params">(<span class="type">int</span> N)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * N ; ++k)  </span><br><span class="line">	&#123;  </span><br><span class="line">		++count;  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> M = <span class="number">10</span>;  </span><br><span class="line">	<span class="keyword">while</span> (M--)  </span><br><span class="line">	&#123;  </span><br><span class="line">		++count;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数，通过分析<br />
拥有两个循环体，一个循环 <code>2*N</code> 次，另一个循环 <code>10</code> 次<br />
按照 大O 渐进表示法，时间复杂度为 <code>O(N)</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算Func2的时间复杂度？  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func2</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; M; ++k)  </span><br><span class="line">	&#123;  </span><br><span class="line">		++count;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; N ; ++ k)  </span><br><span class="line">	&#123;  </span><br><span class="line">		++count;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数，通过分析<br />
拥有两个循环体，一个循环 <code>M</code> 次，另一个循环 <code>N</code> 次<br />
按照 大O 渐进表示法，时间复杂度为 <code>O(M + N)</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算Func3的时间复杂度？  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func3</span><span class="params">(<span class="type">int</span> N)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; ++k)  </span><br><span class="line">	&#123;  </span><br><span class="line">		++count;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数，通过分析<br />
有一个循环体，但是循环体循环次数与传入参数无关，固定循环 <code>100</code> 次<br />
按照 大O 渐进表示法，时间复杂度为 <code>O(1)</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算BubbleSort的时间复杂度？  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	assert(a);  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> end = n; end &gt; <span class="number">0</span>; --end)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="type">int</span> exchange = <span class="number">0</span>;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; end; ++i)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="keyword">if</span> (a[i<span class="number">-1</span>] &gt; a[i])  </span><br><span class="line">			&#123;  </span><br><span class="line">				Swap(&amp;a[i<span class="number">-1</span>], &amp;a[i]); </span><br><span class="line">				exchange = <span class="number">1</span>;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">if</span> (exchange == <span class="number">0</span>)  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数为<code>冒泡排序（排升序）</code><br />
需要分情况分析：<br />
最好的情况是：除了第一位其他都已位升序，则只需要循环 <code>N</code>  次，即 <code>将第一位数据冒泡至最后一位</code><br />
最坏的情况是：数据按照降序排列，则每一个数据都要进行排序，计算执行次数的结果为：<code>(N*(N+1)/2</code> 次<br />
按照 大O 渐进表示法，取最坏的情况时间复杂度为 <code>O(N^2)</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算BinarySearch的时间复杂度？  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> x)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	assert(a);  </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin = <span class="number">0</span>;  </span><br><span class="line">	<span class="type">int</span> end = n<span class="number">-1</span>;  </span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="type">int</span> mid = begin + ((end-begin)&gt;&gt;<span class="number">1</span>);  </span><br><span class="line">		<span class="keyword">if</span> (a[mid] &lt; x)  </span><br><span class="line">			begin = mid+<span class="number">1</span>;  </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)  </span><br><span class="line">			end = mid;  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">			<span class="keyword">return</span> mid;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数为<code>二分查找</code>，<code>(被查找的数据必须是有序的)</code><br />
同样需要分情况分析：<br />
最好的情况：<code>指定数据在数组中间位置，只需要执行一次</code>，即第一次查找就查找到指定数据<br />
最坏的情况：</p>
<blockquote>
<p>二分查找的原理：<code>因为使用二分查找的数据必须是有序的，所以可以通过缩小查找范围来进行查找</code><br />
二分查找每次查找一次，<code>下一次查找的范围会缩小为当前范围的一半</code><br />
只需要一张动图就可解释：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/BinarySearch.gif" alt="" /><br />
可以看出，每次查找之后，下一次需要查找的元素只剩下一半，所以最坏的情况其实是 需要查找：<code>log N</code>次<br />
<code>复杂度中，log N即为 以2为底N的对数</code></p>
</blockquote>
<p>所以按照 大O 渐进表示法，取最坏的情况时间复杂度为 <code>O(log N)</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算阶乘递归Fac的时间复杂度？  </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Fac</span><span class="params">(<span class="type">size_t</span> N)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> == N)  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Fac(N<span class="number">-1</span>)*N;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数为 <code>递归求阶乘</code><br />
递归求阶乘，通过计算可以算出，求<code>N的阶乘</code> 则函数调用了 <code>N</code>次<br />
所以按照 大O 渐进表示法，时间复杂度为 <code>O(N)</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算斐波那契递归Fib的时间复杂度</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Fib</span><span class="params">(<span class="type">size_t</span> N)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">if</span>(N &lt; <span class="number">3</span>)  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Fib(N<span class="number">-1</span>) + Fib(N<span class="number">-2</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数为 <code>递归求斐波那契数列</code><br />
递归求斐波那契数列，一个简单的递归分析图：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Fib_5.jpg" alt="" /><br />
发现正常调用函数，会再发生两次递归，所以应该是 <code>2^N</code><br />
但是因为当 <code>N &lt; 3</code> 会返回 <code>1</code>，不再递归，所以应该是 <code>2^N - x</code> <code>(不容易计算所以用 x 表示)</code>，但是无论怎样，相减的常数因该是对<code>2^N</code> 造不成多大影响的<br />
所以按照 大O 渐进表示法，时间复杂度为 <code>O(2^N)</code></p>
</blockquote>
<hr />
<p>练习结束，感觉如何？？</p>
<h1 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度"></a> 空间复杂度</h1>
<p><strong><code>空间复杂度</code></strong> 主要衡量一个算法运行所需要的额外空间<br />
这里提到一个词：<strong><code>额外空间</code></strong></p>
<p>为什么是 <code>额外空间</code> ？<br />
因为，<code>函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，在函数运行前就已经确定了一部分空间，这些空间的占用不能由算法本身决定</code><br />
所以，空间复杂度主要通过 <code>函数在运行时候申请的额外空间</code> 来确定。</p>
<blockquote>
<p>这里推荐一篇 详细又简单 的 函数栈帧 的好文章：<br />
<a href="https://dxyt-july.cn/posts/Function-Stack-Frame.html">【程序员的自我修养】[动态图文] 超详解函数栈帧</a><br />
<a href="https://dxyt-july.cn/posts/Function-Stack-Frame.html" target="-blank" title="【程序员的自我修养】[动态图文] 超详解函数栈帧" ><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Laugh.jpg"></p>
</blockquote>
<blockquote>
<pre><code>  在函数内使用动态开辟内存的函数，以及创建柔性数组等操作，就会增加函数的额外空间哦
</code></pre>
</blockquote>
<p><code>空间复杂度</code> 和 <code>时间复杂度</code> 的表示方法一样，都用 大O渐进表示法。</p>
<h2 id="空间复杂度的计算举例"><a class="markdownIt-Anchor" href="#空间复杂度的计算举例"></a> 空间复杂度的计算举例</h2>
<p>依然举几个例子：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算BubbleSort的空间复杂度？  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	assert(a);  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> end = n; end &gt; <span class="number">0</span>; --end)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="type">int</span> exchange = <span class="number">0</span>;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; end; ++i)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="keyword">if</span> (a[i<span class="number">-1</span>] &gt; a[i])  </span><br><span class="line">			&#123;  </span><br><span class="line">				Swap(&amp;a[i<span class="number">-1</span>], &amp;a[i]); </span><br><span class="line">				exchange = <span class="number">1</span>;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">if</span> (exchange == <span class="number">0</span>)  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析代码可以看出，冒泡排序额外使用的空间并没有与 <code>N</code> 发生关联。使用了常量个额外空间<br />
所以 按照 大O 渐进表示法，空间复杂度为 <code>O(1)</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算Fibonacci的空间复杂度？  </span></span><br><span class="line"><span class="comment">// 返回斐波那契数列的前n项  </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>* <span class="title function_">Fibonacci</span><span class="params">(<span class="type">size_t</span> n)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)  </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> * fibArray = (<span class="type">long</span> <span class="type">long</span> *)<span class="built_in">malloc</span>((n+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));  </span><br><span class="line">	fibArray[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">	fibArray[<span class="number">1</span>] = <span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n ; ++i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		fibArray[i] = fibArray[i - <span class="number">1</span>] + fibArray [i - <span class="number">2</span>];  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fibArray;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是使用 <code>数组实现的计算斐波那契数列的 前N 项</code><br />
分析代码可以看出，这段代码 使用 <code>malloc</code> 函数开辟了 <code>n+1</code> 个 <code>long long</code>类型的空间，即额外使用的空间与 <code>N</code> 1:1相关<br />
所以 按照 大O 渐进表示法，空间复杂度为 <code>O(N)</code></p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算阶乘递归Fac的空间复杂度？  </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Fac</span><span class="params">(<span class="type">size_t</span> N)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">if</span>(N == <span class="number">0</span>)  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Fac(N<span class="number">-1</span>)*N;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>递归求N的阶乘</code><br />
分析代码可以看出，代码执行需要递归 <code>N</code> 次，且每次递归都需要开辟函数栈帧，<code>每次函数栈帧开辟都会消耗常量个空间</code>，所以是 <code>常量 * N</code><br />
按照 大O 渐进表示法，空间复杂度为 <code>O(N)</code></p>
</blockquote>
<hr />
<p>以上内容就是 关于 <strong><code>时间复杂度</code></strong> 和 <strong><code>空间复杂度</code></strong>  的介绍。<br />
复杂度需要进行学习的已经介绍的差不多了。<br />
但是，需要注意的是<br />
<code>其实大部分的代码，时间、空间复杂度是不容易直接看出来的，一定要执行分析。对存在循环体的代码，也不要直接简单粗暴的去数循环体执行的次数，因为循环并不一定是都需要执行的。一定要分析。</code></p>
<hr />
<h1 id="复杂度对比"><a class="markdownIt-Anchor" href="#复杂度对比"></a> 复杂度对比</h1>
<p>常见的复杂度都有什么呢？</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Com_com.jpg" alt="" /><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Com_FUN.jpg" alt="" /></p>
<hr />
<h1 id="结束语"><a class="markdownIt-Anchor" href="#结束语"></a> 结束语</h1>
<p>数据结构与算法关于复杂度的部分到这里就介绍完了。<br />
本篇文章是对 <code>数据结构与算法</code> 这片<code>神秘海域</code>的初探索。<br />
同样也是 <code>向更深海域探索的重要基石</code></p>
<hr />
<p>感谢阅读！<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/fangun_dog.gif" alt="" /><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/fangun_dog.gif" alt="" /><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/fangun_dog.gif" alt="" /></p>
]]></content>
      <categories>
        <category>神秘海域：数据结构与算法</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构与算法</tag>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么防止云服务图床被爬虫爬？给自己的图床添加白名单~</title>
    <url>/posts/Figur-Bed-Whitelist.html</url>
    <content><![CDATA[<h1 id="原由"><a class="markdownIt-Anchor" href="#原由"></a> 原由</h1>
<p>大家好啊！我是七月<br />
上个月发生了一件让许多人破防的一件事：<code>Gitee 图床炸了</code></p>
<span id="more"></span>
<p>在 <code>Gitee</code> 上建立的图床里的图片全都变成了 <code>Gitee</code> 的图标：<br />
<img src="https://img-blog.csdnimg.cn/3ffc2687b14840ef87c27e14844d9cfb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiD5pyISnVseS4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述" /></p>
<p>这波事故过后一定有许多小伙伴也不敢再在 <code>Gitee</code> 创建图床，免得把再自己给整破防了。<br />
肯定有许多小伙伴转到了 <code>阿里云</code> 等云平台服务重新建立了自己的图床。<br />
但是在 云平台服务建立图床 <code>不是免费的</code>，无论是空间还是流量都不是免费的。<br />
所以，对自己图床访问的限制也就变得尤为重要。<br />
<strong><code>不然自己的云服务就可能被爬虫摧残！！</code></strong> <code>(我已经有了惨痛的教训,都是金钱的教训)</code><br />
下面就来具体说明一下，<code>如何给自己的图床设置白名单</code>，来阻隔各路爬虫的访问。</p>
<hr />
<h1 id="给图床设置白名单"><a class="markdownIt-Anchor" href="#给图床设置白名单"></a> 给图床设置白名单</h1>
<p>这里以 <code>阿里云</code> 为例 <code>( 阿里云手机暂不支持操作，或者是我没找到如何修改 )</code></p>
<p>首先，在自己的 <code>OSS管理控制台</code> 进入<code>需要设立白名单的Bucket</code><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/OSS_1.png" alt="请添加图片描述" /><br />
然后再左边列表选择 <code>权限管理-&gt;防盗链</code><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/OSS_2.png" alt="" /></p>
<p>然后找到 <code>开启防盗链</code>，并打开<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/OSS_3.png" alt="" /></p>
<p>打开后，在 <code>Referer</code> 表里，添加 <code>白名单域名</code> 或 <code>ip</code>  就好了</p>
<h1 id="白名单需要添加什么"><a class="markdownIt-Anchor" href="#白名单需要添加什么"></a> 白名单需要添加什么</h1>
<p><code>白名单(防盗链)</code> 中，添加一般 <code>需要访问图床图片</code> 的 <code>网址</code> 和 <code>ip</code></p>
<p>比如，我们在 <code>C站</code> 写博客需要访问图床外链，就把 <code>C站的域名</code> 添加进去：<code>*.csdn.net</code></p>
<p>或者，需要在 <code>阿里云OSS</code> 预览图片：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/cover_OSS.png" alt="" /></p>
<p>也需要将 <code>阿里云</code> 的域名添加进去，如果不添加就会变成这样：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/cover_OSS_2.png" alt="" /></p>
<p>将 <code>需要访问图床图片的网站域名</code> 添加进去之后，指定网站就可以访问获取图片了 !</p>
<p>这里我添加了需要访问图片的域名：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Referer_yuming.png" alt="" /><br />
添加域名的方式，阿里云有给手册 ：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/For_star.png" alt="" /></p>
<p>添加完成后，就可以<code>防止白名单外的网站访问图床内的图片</code>，就可以 <code>防止爬虫访问导致流量疯狂外流</code>。</p>
<h2 id="添加-ip-建议"><a class="markdownIt-Anchor" href="#添加-ip-建议"></a> 添加 ip 建议</h2>
<p>添加完网站域名，我还推荐 <code>将自己常用网络的ip地址</code> 添加至白名单。否则本地访问 图床图片时 会被拒绝导致访问失败。</p>
<p>考虑到有些小伙伴可能不知道自己的 网络 <code>ip</code>，这里提供一下查询方法<code>(Windows平台)</code>：</p>
<blockquote>
<ol>
<li>使用 <code>CMD</code> 指令查看：<br />
先打开 <code>CMD</code> 或 <code>Terminal(Win11)</code>：<br />
<code>CMD</code>：可以 <code>Win + R</code> 组合键唤出  <code>运行</code>，然后输入 <code>CMD</code> 运行就可以<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/run_CMD.png" alt="" /></li>
</ol>
</blockquote>
<blockquote>
<p><code>Terminal(Win11)</code> ：右键 <code>开始按钮</code> 选择 <code>终端(Terminal)</code> 就可以<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/run_Terminal.png" alt="" /></p>
</blockquote>
<blockquote>
<p>然后在弹出的界面输入 <code>ipconfig /all</code> 回车<br />
就可以找到 <code>当前网络 ip</code>：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/now_ip_adress.png" alt="" /></p>
<ol start="2">
<li>开始界面打开 <code>设置</code>，并打开 <code>网络与Internet</code>，找到 <code>属性</code> 点击就可以看到 <code>当前网络ip</code>：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/now_ip_adress2.png" alt="" /></li>
</ol>
</blockquote>
<p>找到自己的 <code>网络 ip</code> 然后添加到 <code>阿里云OSS</code> <code>防盗链(白名单)</code> 里就 OK 啦！</p>
<hr />
<p>OK 本篇文章到这里就结束了！</p>
<p><code>祝以后的我们的无论使用什么做图床，都不会再挂！！</code></p>
]]></content>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>【C语言初阶】[图文] 二进制文件怎么看？C语言能对文件进行哪些操作？今天我来教你</title>
    <url>/posts/File-Operations.html</url>
    <content><![CDATA[<h1 id="文本文件-二进制文件及其存储"><a class="markdownIt-Anchor" href="#文本文件-二进制文件及其存储"></a> 文本文件、二进制文件及其存储</h1>
<hr />
<p>上一篇介绍过，文件按照功能分类，可以分为 <code>程序文件</code>、<code>数据文件</code> 两类。</p>
<p>此外，文件的分类还有其他的分类方法，比如 按照文件数据的组织形式 来分为 <code>二进制文件</code> 和 <code>文本文件</code>。</p>
<span id="more"></span>
<hr />
<h2 id="文本文件和二进制文件"><a class="markdownIt-Anchor" href="#文本文件和二进制文件"></a> 文本文件和二进制文件</h2>
<p>具体什么是文本文件，什么是二进制文件呢？</p>
<p>关于文本文件，一般我们自己创建并写入内容的文档，或者 Markdown 文件等，都是可以看懂内容的的，这些都属于文本文件的。</p>
<p>比如：</p>
<blockquote>
<p>一个 <code>.txt</code> 文件:  <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-TEXT_FILE.png" alt="TEXT_FILE" style="zoom: 80%;" />，或者 一个 <code>.md</code> 文件 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BINARY_FILE.png" alt="BINARY_FILE" style="zoom:50%;" /></p>
</blockquote>
<p>而对于二进制文件，一般人打开二进制文件是没有办法直接看懂的，因为大部分内容都是乱码</p>
<p>除非用二进制的编辑器打开才会显示二进制的形式，不过一般人还是无法看懂的</p>
<blockquote>
<p>类似这样：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BINARY_READ1.png" alt="BINARY_READ1" /></p>
<p>这样：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BINARY_READ2.png" alt="BINARY_READ2" /></p>
<p>或者这样：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BINARY_READ3.png" alt="BINARY_READ3" /></p>
<p>类似于，这些文件，一般人（反正我是）真的看不懂。</p>
</blockquote>
<p>这时候可能有人会说</p>
<blockquote>
<p>那 文本文件不就是，打开后 一般人能看懂的文件</p>
<p>二进制文件不就是，打开后内容都是二进制或者乱码形式的一般人看不懂的文件吗</p>
</blockquote>
<p>啊，确实</p>
<p>但是身为新时代青年的我们，不能这样简单的区分</p>
<p>我们要知道，文本文件 和 二进制文件  在内存中都是如何存储的</p>
<p>虽然两种文本的内容在内存中都是以二进制的形式存储的，但是存储的方式又有其他不同。</p>
<h2 id="文本文件在内存中的存储"><a class="markdownIt-Anchor" href="#文本文件在内存中的存储"></a> 文本文件在内存中的存储</h2>
<blockquote>
<p>文本文件，我们可以直接打开看懂，主要是因为 文本文件存入内存的二进制数据是经过转换的。</p>
<p>在文本文件的内容 存入内存之前，文本文件的所有内容 都会转换为 <code>ASCII 码</code> 的形式，然后再 以 <code>ASCII 码</code> 的二进制数据存入内存中。</p>
<p>也就是，对于文本文件的内容：</p>
<blockquote>
<p>字符类型、数值类型的数据，都会按位转换为 对应的 <code>ASCII码</code> ，然后将 <code>ASCII码</code>对应的二进制数据，存储到内存中</p>
</blockquote>
<p>然后当使用者打开文本文件的时候，也是会经过转换再显示的。</p>
</blockquote>
<h2 id="二进制文件在内存中的存储"><a class="markdownIt-Anchor" href="#二进制文件在内存中的存储"></a> 二进制文件在内存中的存储</h2>
<blockquote>
<p>二进制文件，直接打开一般会有一部分乱码</p>
<p>是因为，二进制文件的内容，不会全部以 <code>ASCII 码</code> 的形式存入内存中，只有字符型的数据，会转换为相应的 <code>ASCII码</code> 再存储至内存。</p>
<p>所以直接打开二进制文件，字符型以外的数据 就会以乱码的形式展现给用户。</p>
<blockquote>
<p>或许会有 打开二进制文件 却发现中文内容也变成了乱码，那可能是文件内容编码不合适导致的</p>
</blockquote>
</blockquote>
<h2 id="数据在内存中的存储"><a class="markdownIt-Anchor" href="#数据在内存中的存储"></a> 数据在内存中的存储</h2>
<blockquote>
<p>介绍完 <code>文本文件</code> 和 <code>二进制文件</code>，会发现有一个共同点：</p>
<p>字符型的数据，都会先转换为 <code>ASCII码</code> 之后，在存储 <code>ASCII码</code> 的二进制数据。</p>
<p>其实是因为，数据在内存中的存储具体是这样的：</p>
<blockquote>
<ol>
<li>字符型的数据，都会 以其对应的 <code>ASCII码</code> 的二进制存储至内存中</li>
<li>数值型的数据，可以 以其对应的 <code>ASCII码</code> 的二进制存储至内存中（文本文件），也可以 直接以数值本身的二进制形式存储至内存中</li>
</ol>
</blockquote>
<p>那么，数值型的数据 的两种不同形式的存储 有没有什么区别呢？</p>
<p>答案是有的！</p>
<p>举例说明：</p>
<blockquote>
<p>当 我们需要将 99999 存储起来，可以用两种形式：</p>
<blockquote>
<ol>
<li>
<p>以 <code>ASCII码</code> 的形式存储：</p>
<p>需要将<code>9</code> <code>9</code> <code>9</code> <code>9</code> <code>9</code> 分别转换为字符，然后存储其对应的 <code>ASCII码</code>的二进制</p>
<p>即：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-ASCII.png" alt="DATA_STORAGE-ASCII" /></p>
<p><code>VS2013</code>:<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-ASCII-READ.png" alt="ASCII-READ." /></p>
</li>
<li>
<p>直接以数值的二进制存储：</p>
<p>即：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-BINARY.png" alt="DATA_STORAGE-BINARY" /></p>
<p><code>VS2013</code>：对文件中以二进制输出 <code>99999</code></p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-BINARY-READ.png" alt="BINARY-READ1" /></p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-BINARY-READ2.png" alt="BINARY-READ2" /></p>
</li>
</ol>
</blockquote>
<p>我们可以非常明确的看到，对于同一个数值型数据，以 <code>99999</code> 为例</p>
<p>如果以 <code>ASCII码</code>形式 存储，占用 5 字节 内存</p>
<p>如果直接以 数值的二进制形式 存储，占用 4 字节 内存</p>
<p>所以，数值型数据的两种不同的存储方式，在内存方面 是有一定的区别的。</p>
</blockquote>
</blockquote>
<p>看完这些，相信都可以理解究竟什么是二进制文件，什么是文本文件了吧！</p>
<hr />
]]></content>
      <categories>
        <category>C语言初阶</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>【神秘海域】[动图] 顺序表千字破解~</title>
    <url>/posts/DS-SeqList.html</url>
    <content><![CDATA[<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/DS_Cover_qesList.jpg" alt="" /></p>
<hr />
<h1 id="顺序表引言"><a class="markdownIt-Anchor" href="#顺序表引言"></a> 顺序表引言</h1>
<p>数据结构中有 <code>四大基础结构</code> ，即 <code>四大线性表</code>：<strong><code>顺序表</code></strong>、<code>链表</code>、<code>栈</code>、<code>队列</code></p>
<p>被称为线性表是因为，数据用以上四种结构存储，再逻辑结构上都是 <code>在一条线上相邻连续的</code></p>
<span id="more"></span>
<table>
<thead>
<tr>
<th style="text-align:left">线性结构</th>
<th style="text-align:left">逻辑结构图示：</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">顺序表</td>
<td style="text-align:left"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SeqList_photo.jpg" style="zoom:50%;" /></td>
</tr>
<tr>
<td style="text-align:left">链表</td>
<td style="text-align:left"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/List_photo.jpg" style="zoom:50%;" /></td>
</tr>
<tr>
<td style="text-align:left">栈</td>
<td style="text-align:left"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Stack_photo.jpg" style="zoom:50%;" /></td>
</tr>
<tr>
<td style="text-align:left">队列</td>
<td style="text-align:left"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Queue_photo.jpg" style="zoom:50%;" /></td>
</tr>
</tbody>
</table>
<p>本篇文章将详细介绍 <strong><code>顺序表</code></strong> 的 <code>结构</code> <code>增</code> <code>删</code> <code>查</code> <code>改</code> <code>插入</code> 等操作。</p>
<h1 id="顺序表"><a class="markdownIt-Anchor" href="#顺序表"></a> 顺序表</h1>
<h2 id="顺序表的概念"><a class="markdownIt-Anchor" href="#顺序表的概念"></a> 顺序表的概念</h2>
<p>先来了解一下什么是 顺序表：<code>用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改</code><br />
本质来说上，顺序表 就是一个实现增删查改等操作 的数组。</p>
<h2 id="顺序表的两种结构"><a class="markdownIt-Anchor" href="#顺序表的两种结构"></a> 顺序表的两种结构</h2>
<p>顺序表的实现方式一般分为两种：</p>
<ol>
<li>静态的顺序表<br />
所谓<code>静态</code>，就是 <code>使用定长数组存储数据</code><br />
定长的数组是 <code>有一定的弊端</code> 的，即 <code>只能存储一定数量的数据</code><br />
即：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Quiet_Seq.gif" alt="" /><br />
采用定长的数组实现顺序表，<code>顺序表存满(即数组存满)之后，无法直接继续存储数据，想要继续存储数据就需要改动源代码.</code><br />
一般实现代码为：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SLDataType a[N];    <span class="comment">// SLDataType 表示数据类型，已经被typedef 为 int</span></span><br><span class="line">	<span class="type">int</span> Size;    <span class="comment">//数组内存放数据数量</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要改变顺序表的容量就需要改动 N 的值</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>动态的顺序表<br />
<code>动态的顺序表</code>，就是 <code>使用动态开辟的数组存储数据</code><br />
动态开辟的数组，可以实现一个功能就是，<code>当数组满了的时候可以自动扩容</code><br />
即：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/dynamic_SeqList.gif" alt="" /><br />
当数组处于已满的状态且再要存入数据时，数组扩容。<br />
这样采用动态数组实现的顺序表，<code>使用的时候不需要考虑容量的问题</code> ，所以 一般 <code>实现顺序表就用动态开辟的数组</code> 实现。<br />
结构的实现代码为：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SLDataType* arr;    <span class="comment">// 指向动态开辟的数组</span></span><br><span class="line">	<span class="type">int</span> Size;    <span class="comment">//数组内存放数据数量</span></span><br><span class="line">	<span class="type">int</span> Capacity;    <span class="comment">//顺序表容量</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"><span class="comment">// 此结构的顺序表 创建后，使用前，需要初始化</span></span><br></pre></td></tr></table></figure>
<h2 id="顺序表接口实现"><a class="markdownIt-Anchor" href="#顺序表接口实现"></a> 顺序表接口实现</h2>
<p>静态顺序表 <code>只适用于确定知道需要存多少数据的场景</code><br />
所以现实中基本都是使用动态顺序表，根据需要动态的分配空间大小</p>
<pre><code>以下也都是以动态顺序表为基础
</code></pre>
<p>一个动态顺序表一般拥有这些接口：</p>
<ol>
<li>初始化    <code>seqListInit</code></li>
<li>容量检查    <code>checkCapacity</code></li>
<li>尾插    <code>seqListPushBack</code></li>
<li>尾删    <code>seqListPopBack</code></li>
<li>头插    <code>seqListPushFront</code></li>
<li>头删    <code>seqListPopFront</code></li>
<li>查找    <code>seqListFind</code></li>
<li>指定位置插入    <code>seqListInsert</code></li>
<li>指定位置删除    <code>seqListErase</code></li>
<li>销毁顺序表    <code>seqListDestory</code></li>
<li>打印顺序表    <code>seqListPrint</code></li>
</ol>
<p>下面就来一一实现这些接口:</p>
<h3 id="顺序表动态存储结构"><a class="markdownIt-Anchor" href="#顺序表动态存储结构"></a> 顺序表动态存储结构</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SLDataType* arr;    <span class="comment">// 指向动态开辟的数组</span></span><br><span class="line">	<span class="type">int</span> Size;    <span class="comment">//数组内存放数据数量</span></span><br><span class="line">	<span class="type">int</span> Capacity;    <span class="comment">//顺序表容量</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"><span class="comment">// 此结构的顺序表 创建后，使用前，需要初始化</span></span><br></pre></td></tr></table></figure>
<p>实现动态顺序表结构，需要在结构体内</p>
<h3 id="顺序表初始化"><a class="markdownIt-Anchor" href="#顺序表初始化"></a> 顺序表初始化</h3>
<pre><code>// 顺序表初始化
void seqListInit(SeqList* psl); 
</code></pre>
<p>初始化函数非常的简单，只需要将创建好的顺序表结构体内：<br />
<code>arr</code> 指向 <code>NULL</code><br />
<code>Size</code> 和 <code>Capacity</code> 赋予 <code>0</code><br />
就完成了一个顺序表的初始化</p>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListInit</span><span class="params">(SeqList* psl)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line"></span><br><span class="line">	psl-&gt;arr = <span class="literal">NULL</span>;</span><br><span class="line">	psl-&gt;Size = psl-&gt;Capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个顺序表验证一下：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SLInit.jpg" alt="" /><br />
创建出的顺序表，初始化成功。</p>
<h3 id="顺序表尾插-及-容量检查"><a class="markdownIt-Anchor" href="#顺序表尾插-及-容量检查"></a> 顺序表尾插 及 容量检查</h3>
<pre><code>// 顺序表容量检查
void checkCapacity(SeqList* psl);
// 顺序表尾插
void seqListPushBack(SeqList* psl, SLDataType x);
</code></pre>
<p>顺序表尾插，即 <code>在顺序表最后一个数据之后存放数据</code><br />
存放数据进入顺序表之前，要 <code>先确保顺序表处于未满状态</code> 的，不然数据无法存储。</p>
<p>所以在实现尾插之前，先 <code>实现一个容量检查的函数</code> 。<br />
<code>容量检查一般需要实现什么功能？</code></p>
<ol>
<li>检查顺序表是否已满</li>
<li>如果顺序表已满，则扩容</li>
</ol>
<p>具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">checkCapacity</span><span class="params">(SeqList* psl)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(psl-&gt;Size == psl-&gt;Capacity)</span><br><span class="line">	&#123;<span class="comment">// 如果存入的数据数量 与 顺序表的容量相等，就代表顺序表已满</span></span><br><span class="line">		<span class="type">int</span> newCapacity = psl-&gt;Capacity == <span class="number">0</span> ? <span class="number">2</span> : <span class="number">2</span> * psl-&gt;Capacity;    </span><br><span class="line">		<span class="comment">//如果当前容量等于0,代表新顺序表,新容量给 2</span></span><br><span class="line">		<span class="comment">//如果当前容量不等于0,代表非新顺序表，新容量给原来容量的两倍</span></span><br><span class="line">		SLDataType* tmp = (SLDataType*)<span class="built_in">realloc</span>(psl-&gt;arr, <span class="keyword">sizeof</span>(SLDataType)* newCapacity);</span><br><span class="line">		<span class="comment">// 先用tmp 指向 realloc 扩容出新空间，以防止扩容失败导致元数据丢失</span></span><br><span class="line">		<span class="keyword">if</span>(tmp == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;<span class="comment">// tmp 为空 表示扩容失败，退出程序</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;realloc fail!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// tmp 不为空，再将tmp 赋于 psl-&gt;arr;</span></span><br><span class="line">		psl-&gt;arr = tmp;  <span class="comment">//psl-&gt;arr 指向扩容后的地址</span></span><br><span class="line">		psl-&gt;Capacity = newCapacity;   <span class="comment">// 容量改为扩容后的容量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容量检查函数实现成功之后，就可以继续 <code>实现尾插函数</code>：</p>
<p>先考虑一下，<code>尾插都需要注意哪些事项</code>：</p>
<ol>
<li>需要先用容量检查函数检查容量</li>
<li>需要在数组中 <code>Size</code> 的位置放入数据之后，<code>Size</code> 自增<br />
<code>(因为数组下标从 0 开始，所以 Size 位置即为最后一个数据之后)</code></li>
</ol>
<p>具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPushBack</span><span class="params">(SeqList* psl, SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);    <span class="comment">//断言保证传入的结构体的地址不为空</span></span><br><span class="line"></span><br><span class="line">	checkCapacity(psl);    <span class="comment">//容量检查函数检查容量</span></span><br><span class="line"></span><br><span class="line">	psl-&gt;arr[psl-&gt;Size] = x;    <span class="comment">// 将 x 尾插</span></span><br><span class="line">	psl-&gt;Size++;    <span class="comment">// 存储数据量加1 , Size也要加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>每实现一个接口，最好都要验证一下</code></p>
<p>尾插三个整型数据，验证<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SLPushBack_blog.jpg" alt="" /></p>
<p>尾插三次，扩容两次，尾插成功.</p>
<h3 id="顺序表打印"><a class="markdownIt-Anchor" href="#顺序表打印"></a> 顺序表打印</h3>
<pre><code>// 顺序表打印
void seqListPrint(SeqList* psl);
</code></pre>
<p>尾插存放数据是可以了，但是如何实现顺序表的打印呢？</p>
<p><code>顺序表打印</code> 接口的实现也是非常的简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPrint</span><span class="params">(SeqList* psl)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; psl-&gt;Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, psl-&gt;arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SLPrint_blog.jpg" alt="" /></p>
<h3 id="顺序表尾删"><a class="markdownIt-Anchor" href="#顺序表尾删"></a> 顺序表尾删</h3>
<pre><code>// 顺序表尾删
void seqListPopBack(SeqList* psl);
</code></pre>
<p>实现了顺序表的尾插，如果需要删除数据，对应的还有顺序表的尾删。</p>
<p>尾删需要注意几个点：</p>
<ol>
<li>尾删需不需要将 <code>需要删除的数据</code> 的空间释放掉？</li>
<li>尾删需不需要将 <code>需要删除的数据</code> 赋值为 <code>0</code> ?</li>
<li>尾删需不需要控制一下顺序表中的 <code>Size</code> ？</li>
<li>控制不控制 <code>Size</code> 的值，对顺序表来说有什么区别？</li>
</ol>
<p>先来思考一下第一个问题，尾删需不需要将 <code>需要删除的数据</code> 的空间释放掉？<br />
答案是，不需要，也无法释放。<br />
因为 <code>free</code> 函数使用的条件是，<code>malloc</code> 或 <code>realloc</code> 函数开辟的<code>整块空间</code>，且<code>传入的必须是是这块空间的首地址</code>。所以无法释放其中的单独一块空间。</p>
<p>第二个问题，尾删需不需要将 <code>需要删除的数据</code> 赋值为 <code>0</code> ?</p>
<p>答案同样是，不需要。<br />
因为尾删之后，<code>下次使用这块空间一定是在插入数据的时候，到时候会有新的数据将其覆盖，所以不需要将其赋值为</code>0`</p>
<p>第三个问题和第四个问题，一起思考一下：</p>
<p>尾删需不需要控制一下顺序表中的 <code>Size</code> ？<br />
控制不控制 <code>Size</code> 的值，对顺序表来说有什么区别？</p>
<p>答案是，需要控制 <code>Size</code> 的值，防止 过多次使用尾删<code>(使用次数比存放数据数量多)</code> 导致 <code>Size</code> 变成负数。<br />
<code>Size</code> 变成负数，会发生什么情况？</p>
<p>使用下面段 尾删函数试验一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表尾删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPopBack</span><span class="params">(SeqList* psl)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line"></span><br><span class="line">	psl-&gt;Size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/popBack_beyond.jpg" alt="" /><br />
<code>尾插 3 个数据，但是尾删了 5 次</code><br />
可以看到，顺序表中的 <code>Size</code> 变成了 <code>-3</code><br />
变成负数之后，如果继续进行其他操作，一定会发生错误<br />
比如：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/popBack_beyond3.jpg" alt="" /><br />
即使，尾插了两次，顺序表中还是无法输出数据，也就是说，再次尾插的两个数据并没有存放至顺序表中。<br />
因为 这两次尾插，是从 <code>Size 为 -3</code> 的地方执行的，并没有从 <code>0</code> 位置开始，所以无法存入，<code>同时也发生了越界现象</code>。</p>
<blockquote>
<p>这里 <code>VS 编译器</code> 不报错，是因为 <code>对于数组越界的情况， VS编译器 是抽查的</code>。也就是说，并不是所有的越界情况 <code>VS编译器</code> 都能检查得到</p>
</blockquote>
<p>所以<code>尾删</code>，需要对顺序表中的 <code>Size</code> 进行一个简单的控制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表尾删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPopBack</span><span class="params">(SeqList* psl)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (psl-&gt;Size &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;<span class="comment">// 当Size 大于零 再进行自减</span></span><br><span class="line">		psl-&gt;Size--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不会发生使 <code>Size</code> 减到负 的问题：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/popBack_beyond2.jpg" alt="" /><br />
即使 尾删次数过多，<code>Size</code> 也不会变为负数，也就不会发生其他操作错误的情况。</p>
<h3 id="顺序表头插"><a class="markdownIt-Anchor" href="#顺序表头插"></a> 顺序表头插</h3>
<pre><code>// 顺序表头插
void seqListPushFront(SeqList* psl, SLDataType x);
</code></pre>
<p>顺序表的尾插比较简单，只需要在顺序表 <code>Size</code> 位置放入数据就可以了。</p>
<p>头插呢？头插需要注意到什么问题？<br />
顺序表本质上是 <code>数组实现的</code>，那么需要在数组的首位置插入数据就不仅仅是插入数据那么简单。<code>需要先将数组中的数据向后移动一位，然后才能将新数据放入首位置</code><br />
<code>演示：</code><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/PushFront.gif" alt="" /></p>
<p><code>那么来实现头插一下：</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPushFront</span><span class="params">(SeqList* psl, SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);    <span class="comment">//断言保证传入的结构体的地址不为空</span></span><br><span class="line"></span><br><span class="line">	checkCapacity(psl);    <span class="comment">//插入前 首先检查容量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法一：</span></span><br><span class="line">	<span class="type">int</span> end = psl-&gt;Size;</span><br><span class="line">	<span class="keyword">while</span> (end)</span><br><span class="line">	&#123;</span><br><span class="line">		psl-&gt;arr[end] = psl-&gt;arr[end - <span class="number">1</span>];</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法二：</span></span><br><span class="line">	<span class="comment">/*int end = psl-&gt;Size - 1;</span></span><br><span class="line"><span class="comment">	while (end &gt;= 0)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		psl-&gt;arr[end + 1] = psl-&gt;arr[end];</span></span><br><span class="line"><span class="comment">		end--;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这两个方法其实一样的，只是对 末尾元素的位置控制方式不同</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	psl-&gt;arr[<span class="number">0</span>] = x;    <span class="comment">// 将 x 尾插</span></span><br><span class="line">	psl-&gt;Size++;    <span class="comment">// 存储数据量加1 , Size 加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/seqListPushFront.jpg" alt="" /></p>
<p>头插成功。</p>
<h3 id="顺序表头删"><a class="markdownIt-Anchor" href="#顺序表头删"></a> 顺序表头删</h3>
<pre><code>// 顺序表头删
void seqListPopFront(SeqList* psl);
</code></pre>
<p>实现了头插，接着来实现一下头删</p>
<p>头删和头插的思路相似，不过只是将从 <code>1 ~ Size-1</code> 位置的数据向前移动一位。<br />
不过，头删同样需要保证 <code>Size &gt; 0</code> 才能执行。<br />
<code>演示：</code><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/PopFront.gif" alt="" /></p>
<p><code>头删实现：</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表头删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPopFront</span><span class="params">(SeqList* psl)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (psl-&gt;Size &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> begin = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt; psl-&gt;Size)</span><br><span class="line">		&#123;</span><br><span class="line">			psl-&gt;arr[begin] = psl-&gt;arr[begin - <span class="number">1</span>];</span><br><span class="line">			begin++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		psl-&gt;Size--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/popFront_beyond.jpg" alt="" /><br />
即使删除过多，也不会出错。</p>
<h3 id="顺序表查找"><a class="markdownIt-Anchor" href="#顺序表查找"></a> 顺序表查找</h3>
<pre><code>int seqListFind(SeqList* psl, SLDataType x);
</code></pre>
<p>查找顺序表中某个数据所在的位置，可以用到顺序表查找的操作。<br />
因为顺序表的本质是数组，所以 <code>只需要将顺序表从头到尾遍历一遍</code>，找到值就返回 <code>其所在的位置</code> ，找不到就返回 <code>-1</code>。</p>
<p>查找的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">seqListFind</span><span class="params">(SeqList* psl, SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; psl-&gt;Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == psl-&gt;arr[i])</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/seqListFind.jpg" alt="" /><br />
验证了，一般情况、边界情况、未找到情况，均返回正确。</p>
<h3 id="指定位置插入"><a class="markdownIt-Anchor" href="#指定位置插入"></a> 指定位置插入</h3>
<pre><code>void seqListInsert(SeqList* psl, size_t pos, SLDataType x);
</code></pre>
<p>尾插、头插都实现了，接下来就实现一下指定 <code>pos</code> 位置插入数据。<br />
在指定 <code>pos</code> 位置插入数据，和前插有一点相似，需要将数据向后移一位。</p>
<p>我们可以用相似的方法移动，不过是从 <code>pos</code> 位置以后的数据向后移动一位。<br />
不过首先还是要检查容量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定位置插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListInsert</span><span class="params">(SeqList* psl, <span class="type">size_t</span> pos, SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line">	</span><br><span class="line">	SeqListCheckCapacity(psl);    <span class="comment">// 检查容量</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">size_t</span> end = psl-&gt;Size;</span><br><span class="line">	<span class="keyword">while</span>(end &gt; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		psl-&gt;arr[end] = psl-&gt;arr[end - <span class="number">1</span>];</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	psl-&gt;arr[pos] = x;</span><br><span class="line">	psl-&gt;Size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证一下：</p>
<blockquote>
<p>在插入之前可以使用 查找函数 获取一下 <code>pos</code> 位置</p>
</blockquote>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SeqList_posInsert.jpg" alt="" /><br />
<code>pos</code> 位置插入数据 成功了。</p>
<p>但是真的成功了吗？<br />
这个函数，现在还有没有什么问题？<br />
比如，当我在 <code>20</code> 这个位置插入，会发生什么呢？<br />
看一下：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SeqList_posInsert2.jpg" alt="" /><br />
在 <code>20</code> 位置插入数据没有报错，但是输出的时候输出的是随机值<br />
而且，在实际的操作中，程序是延迟了一会才结束的<br />
为什么？</p>
<p>因为，顺序表中存放的数据数量只有 <code>9</code> 个，占用的位置只有<code>0 ~ 8</code>，如果在 <code>20</code> 位置插入数据，超出了顺序表应有的位置，这个时候 <code>Size</code> 照常自增<br />
那么输出的时候就会输出 <code>0 ~ 9</code> 位置的数据，而 <code>9</code> 位置并没有赋予数据，所以输出的是随机值。</p>
<p>这就提出了一个问题：当传入的 <code>pos</code> 位置比实际应该插入的位置大，怎么解决？<br />
其实也很简单，如果 <code>pos</code> 位置过大，<code>直接结束 插入函数</code> 就可以了。</p>
<p>那么改进后的代码就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定位置插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListInsert</span><span class="params">(SeqList* psl, <span class="type">size_t</span> pos, SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line">	</span><br><span class="line">	checkCapacity(psl);    <span class="comment">// 检查容量</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(pos &gt; psl-&gt;Size)</span><br><span class="line">	&#123;<span class="comment">// 尾插的位置是 Size，如果大于Size，就代表pos过大</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Insert fail. Pos &gt; Size! Pos = %d \n&quot;</span>, pos);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">size_t</span> end = psl-&gt;Size;</span><br><span class="line">	<span class="keyword">while</span>(end &gt; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		psl-&gt;arr[end] = psl-&gt;arr[end - <span class="number">1</span>];</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	psl-&gt;arr[pos] = x;</span><br><span class="line">	psl-&gt;Size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再执行一遍代码：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SeqList_posInsert3.jpg" alt="" /><br />
当 <code>pos</code> 大于 <code>Size</code> 时，会输出警告，并停止插入。</p>
<h4 id="调用指定位置插入的-尾插-和-头插"><a class="markdownIt-Anchor" href="#调用指定位置插入的-尾插-和-头插"></a> 调用指定位置插入的 尾插 和 头插</h4>
<p>那么。<br />
既然插入函数可以指定位置插入数据，是不是就说明 <code>头插</code> <code>尾插</code> 都可以<code>直接调用插入函数</code> 实现呢？<br />
答案当然是可以的。<br />
所以 <code>尾插</code> 和 <code>头插</code> 函数就可以改进为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPushBack</span><span class="params">(SeqList* psl, SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);    <span class="comment">//断言保证传入的结构体的地址不为空</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	checkCapacity(psl);    //容量检查函数检查容量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	psl-&gt;arr[psl-&gt;Size] = x;    // 将 x 尾插</span></span><br><span class="line"><span class="comment">	psl-&gt;Size++;    // 存储数据量加1 , Size也要加1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	seqListInsert(psl, psl-&gt;Size, x);    <span class="comment">//在 Size 位置插入数据，就是尾插</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPushFront</span><span class="params">(SeqList* psl, SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);    <span class="comment">//断言保证传入的结构体的地址不为空</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	checkCapacity(psl);    //插入前 首先检查容量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 方法一：</span></span><br><span class="line"><span class="comment">	int end = psl-&gt;Size;</span></span><br><span class="line"><span class="comment">	while (end)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		psl-&gt;arr[end] = psl-&gt;arr[end - 1];</span></span><br><span class="line"><span class="comment">		end--;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 方法二：</span></span><br><span class="line"><span class="comment">	int end = psl-&gt;Size - 1;</span></span><br><span class="line"><span class="comment">	while (end &gt;= 0)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		psl-&gt;arr[end + 1] = psl-&gt;arr[end];</span></span><br><span class="line"><span class="comment">		end--;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 这两个方法其实一样的，只是对 末尾元素的位置控制方式不同</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	psl-&gt;arr[0] = x;    // 将 x 尾插</span></span><br><span class="line"><span class="comment">	psl-&gt;Size++;    // 存储数据量加1 , Size 加1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	seqListInsert(psl, <span class="number">0</span>, x);   <span class="comment">// 在 0 位置插入数据，就是头插</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用改良后的 <code>头插</code> <code>尾插</code>验证：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/seqListPushBack_Front_UPTATE.jpg" alt="" /><br />
改良后的 <code>头插</code> 和 <code>尾插</code> 成功</p>
<h3 id="指定位置删除"><a class="markdownIt-Anchor" href="#指定位置删除"></a> 指定位置删除</h3>
<pre><code>void seqListErase(SeqList* psl, size_t pos);
</code></pre>
<p>删除 <code>pos</code> 位置的数据，思路也是与 <code>头删</code> 相似。<br />
即，<code>pos</code> 位置以后的数据，向前移动一位，同时 <code>Size</code> 自减</p>
<p>同样的，指定位置删除的 <code>pos</code> 也是要控制一下的</p>
<p>那么，指定位置删除的实现就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定位置删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListErase</span><span class="params">(SeqList* psl, <span class="type">size_t</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pos &gt;= psl-&gt;Size)</span><br><span class="line">	&#123;<span class="comment">// 这里 pos 必须小于 Size 才能删除</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Erase fail. Pos &gt;= Size! Pos = %d \n&quot;</span>, pos);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">size_t</span> begin = pos + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(begin &lt; psl-&gt;Size)</span><br><span class="line">	&#123;</span><br><span class="line">		psl-&gt;arr[begin - <span class="number">1</span>] = psl-&gt;arr[begin];</span><br><span class="line">		begin++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	psl-&gt;Size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证一下：<br />
删除之前插入的三个 <code>0</code>：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/seqListErase.jpg" alt="" /><br />
删除成功，同样 超出 <code>Size</code> 直接取消删除。</p>
<h4 id="调用指定位置删除的-尾删-和-头删"><a class="markdownIt-Anchor" href="#调用指定位置删除的-尾删-和-头删"></a> 调用指定位置删除的 尾删 和 头删</h4>
<p>既然 <code>尾插</code> 和 <code>头插</code> 都可以直接调用 <code>指定位置插入函数</code> 实现<br />
我 <code>尾删</code> 和 <code>头删</code> 也要调用 <code>指定位置删除函数</code></p>
<p>安排：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表尾删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPopBack</span><span class="params">(SeqList* psl)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	if (psl-&gt;Size &gt; 0)</span></span><br><span class="line"><span class="comment">	&#123;// 当Size 大于零 再进行自减</span></span><br><span class="line"><span class="comment">		psl-&gt;Size--;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	seqListErase(psl, psl-&gt;Size - <span class="number">1</span>);    <span class="comment">// Size - 1 即为末尾元素位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表头删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seqListPopFront</span><span class="params">(SeqList* psl)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(psl);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	if (psl-&gt;Size &gt; 0)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		int begin = 1;</span></span><br><span class="line"><span class="comment">		while (begin &lt; psl-&gt;Size)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			psl-&gt;arr[begin] = psl-&gt;arr[begin - 1];</span></span><br><span class="line"><span class="comment">			begin++;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		psl-&gt;Size--;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	seqListErase(psl, <span class="number">0</span>);    <span class="comment">// 0 位置即为首元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也使用改良后的 <code>头删</code> <code>尾删</code>验证：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/seqListErase_FrontBack.jpg" alt="" /><br />
改良后的 <code>头删</code> 和 <code>尾删</code> 成功</p>
<h3 id="顺序表销毁"><a class="markdownIt-Anchor" href="#顺序表销毁"></a> 顺序表销毁</h3>
<pre><code>// 顺序表销毁  
void seqListDestory(SeqList* psl);
</code></pre>
<p>对于顺序表的销毁，比较简单，与初始化相似，一看就懂：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDestory</span><span class="params">(SeqList *psl)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(psl);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(psl-&gt;s);</span><br><span class="line">    psl-&gt;s = <span class="literal">NULL</span>;</span><br><span class="line">    psl-&gt;size = psl-&gt;capacity = <span class="number">0</span>;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>至此 <code>顺序表结构</code>、<code>主要接口</code> 已经全部实现。<br />
阅读到这里的一定都是勤奋好学的hxd了<br />
加油！</p>
<hr />
<h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1>
<p>本篇文章所介绍实现的是 线性表的第一个结构：<code>顺序表</code>。是相对简单的一个数据结构。虽然相对简单，但是也存在着许多需要注意的细节，像<code>检查容量时</code>对 <code>realloc</code> 函数的掌握、 像 <code>删除函数</code> 中 <code>Size</code>的要点、 像 <code>指定位置操作</code> 中  <code>pos</code> 位置的控制 等。都是一些需要用心注意的细节。</p>
<p>好了，本篇文章，也是 <code>【神秘海域】 数据结构与算法</code> 系列的第二篇，至此结束。</p>
<p>感谢阅读！！</p>
<hr />
]]></content>
      <categories>
        <category>神秘海域：数据结构与算法</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构与算法</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>【程序员的自我修养】[动态图文] 超详解函数栈帧</title>
    <url>/posts/Function-Stack-Frame.html</url>
    <content><![CDATA[<p>在阅读这篇文章之前，请思考一下对于下面的这些问题，你有一个准确清晰的认知吗？</p>
<ol>
<li>什么是函数栈帧？</li>
<li>程序中的局部变量，是如何创建的？</li>
<li>为什么局部变量不初始化会是随机值？</li>
<li>函数传参，究竟是如何传参的？</li>
<li>函数的形参和实参存在什么关系？</li>
<li>函数是如何被调用的？</li>
<li>函数被调用之后是如何返回的？</li>
</ol>
<p>如果没有，请尝试阅读、分析、理解本篇文章。<br />
读懂本篇文章将会提升你的“自我修养”。</p>
<blockquote>
<p><code>程序运行背后的机制和由来，可以看作是程序员的一种“自我修养”。</code><br />
<strong>------ 程序员的自我修养 “链接、装载与库”</strong></p>
</blockquote>
<span id="more"></span>
<h1 id="栈与栈帧"><a class="markdownIt-Anchor" href="#栈与栈帧"></a> 栈与栈帧</h1>
<h2 id="什么是栈"><a class="markdownIt-Anchor" href="#什么是栈"></a> 什么是栈？</h2>
<p>在操作系统中，栈是一个动态内存区域。<br />
函数的中的局部变量，都存放在内存的栈区中。<br />
栈区的使用，和数据结构中的栈使用规则相似：<br />
压栈、出栈、先进后出。<br />
栈区总是先使用高地址，再使用低地址，即栈区的使用是 <code>从高地址向低地址延伸</code> 的。</p>
<h2 id="什么是栈帧"><a class="markdownIt-Anchor" href="#什么是栈帧"></a> 什么是栈帧？</h2>
<p>从逻辑上讲，栈帧就是一个函数执行的环境。<br />
栈会保存一个函数被调用所需要的维护信息，保存这些信息所用的信息空间，常被称为 <code>函数栈帧</code>。</p>
<p>每一个函数的调用，都会创建一个独立的栈帧。</p>
<p>维护函数栈帧，需要用 <code>两个寄存器</code> 来记录函数栈帧的大小，也可以叫 划定函数活动记录的范围 ，这两个寄存器存放的是地址，两个地址之间，就是函数的栈帧大小：</p>
<ol>
<li>寄存器 <code>ebp</code>：栈底指针<br />
指向维护栈帧的高地址.</li>
<li>寄存器 <code>esp</code>：栈顶指针<br />
指向维护的栈帧的低地址，会随每次压栈自动向低地址延伸.</li>
</ol>
<h1 id="栈帧是如何创建的"><a class="markdownIt-Anchor" href="#栈帧是如何创建的"></a> 栈帧是如何创建的?</h1>
<blockquote>
<pre><code>  		以下均在Windows平台，VS2013编译环境下演示
  	
  	不同平台，不同编译环境下的栈帧操作可能会有差异，但是逻辑相通。
</code></pre>
</blockquote>
<p>创建一个最简单的可以观察函数栈帧的程序<br />
（步骤划分越细，函数栈帧观察越容易）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line">	z = x + y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	c = Add(a , b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对代码进行调试的时候，对函数栈帧调用进行查看，此时调用 mian 函数栈帧:<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_Main.png" alt="SF_Main" /></p>
<p>将光标继续向后走，走到 <code>21行</code> 之后跳到另外一个界面：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_main__CRTStartup_mainCRTStartup.png" alt="main函数被调用" /><br />
发现，<code>main</code> 函数并不是直接被计算机调用的，而是由另外一个函数所调用</p>
<p>向上翻阅代码，能看到 main 函数其实是在 <code>__mainCRTStartup</code> 函数中被调用<br />
而 <code>__mainCRTStartup</code> 函数，又在 <code>mainCRTStartup</code> 函数中被调用<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_mainCRTStartup_return.png" alt="__mainCRTStartup被调用" /></p>
<p>所以 在调用 <code>main</code> 函数之前，其实已经调用了两个函数，也已经创建了两个函数的栈帧。但是这两个函数的栈帧创建的过程并不容易被看到，所以我们可以观察 main 函数的栈帧的创建来详细了解栈帧的创建。</p>
<p>重新回到，光标刚指向 <code>main</code> 函数的时候，<code>转到反汇编</code>：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_Main_Stack_Frames.png" alt="反汇编" /><br />
右边 <code>反汇编窗口的代码</code> ，其实就是 <code>main</code> 函数中，<code>从函数栈帧创建，到 main 函数结束</code> 的整个操作及顺序。</p>
<p>以动画形式演示：</p>
<ol>
<li>
<p><code>main</code> 函数调用之前，<code>mainCRTStartup</code> 和 <code>__mainCRTStartup</code> 函数的栈帧创建(无详细内容)：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_MAINSRTSTARTUP_PUSH.gif" alt="简单main 函数栈帧创建" style="zoom: 60%;" /></p>
</li>
<li>
<p>进入 <code>main</code> 函数：</p>
</li>
</ol>
<blockquote>
<ol>
<li><code>(push ebp)</code> 压栈，压入内容是 <code>ebp</code> 指向的地址<code>(为保存当前 ebp 内容)``</code>ps：压栈之后，esp(栈顶指针)自动指向栈顶`</li>
<li><code>(mov ebp,esp)</code> 将 <code>ebp</code> 指向 <code>esp</code> 的地址( 将 <code>esp</code> 赋予 <code>ebp</code>)</li>
</ol>
</blockquote>
<p>此时，<code>ebp</code> 和 <code>esp</code> 的实际变化为：</p>
<blockquote>
<p>未执行 :<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/push_esp_ebp_change.png" alt="" /><br />
执行 <code>push ebp</code> :<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/pushA_esp_ebp_change.png" alt="" /><br />
执行 <code>mov ebp,esp</code> :<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/mov_esp_ebp_change.png" alt="" /></p>
</blockquote>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/push_epb.gif" alt="压栈ebp，调整" style="zoom: 60%;" />
3. 此时，反汇编中的语句光标指向了 
<p><code>sub esp,0E4h</code></p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/sub_esp.png" alt="next_esp_sub" /></p>
<p>即下一句执行指令的就是 <code>sub esp,0E4h</code></p>
<blockquote>
<p>汇编语言：<code>sub 相减</code><br />
<code>sub esp,0E4h</code> 指 <code>esp = esp - 0E4h</code><br />
<code>0E4h</code> 是十六进制数，转换成十进制为 228：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/0E4h.png" alt="0E4h" /></p>
</blockquote>
<p>执行<code>sub esp,0E4h</code> 的变化：</p>
<blockquote>
<p>未执行：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/No_sub.png" alt="" /><br />
执行 <code>sub esp,0E4h</code>：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/sub_esp_change.png" alt="" /></p>
</blockquote>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/sub_esp_0E4h.gif" alt="sub esp,0E4h" style="zoom: 60%;" />
<p>执行之后，<code>esp</code> 和 <code>ebp</code> 之间会 存在一块由其新维护的空间<br />
而这段空间其实就是为 <code>main</code> 函数预开辟的空间</p>
<p>查看地址：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/For_main_space.png" alt="For_main_space" style="zoom: 80%;" /><br />
即：从 <code>0x00AFF8A4</code> 到 <code>0x00AFF988</code> 就是为 <code>main</code> 函数与开辟的空间<br />
也被成为 <code>main</code> 函数的栈帧。</p>
<p>但是，这里并不是函数栈帧创建的结束。</p>
<ol start="4">
<li>继续执行汇编指令，光标继续移动：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Push_ebx_esi_edi.png" alt="Push_ebx_esi_edi" /></li>
</ol>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Save_ebx_esi_edi.gif" alt="Save_ebx_esi_edi" style="zoom: 60%;" />
<p>保存了寄存器<code>ebx</code> <code>esi</code> <code>edi</code></p>
<ol start="5">
<li>指令继续执行：</li>
</ol>
<blockquote>
<ol>
<li>执行 <code>lea edi,[ebp-0E4h]</code> ：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/lea_edi.png" alt="lea_edi" /><br />
这里的 <code>ebp-0E4h</code> 地址，经过对比，就是 预开辟的 <code>main</code> 函数栈帧的栈顶地址<code>(0x00AFF8A4)</code></li>
</ol>
<blockquote>
<p>汇编指令 ：<code>lea(Load effect address)</code>   加载有效地址<br />
<code>lea edi,[ebp-0E4h]</code>  即为：加载有效地址 <code>ebp-0E4h</code> 至寄存器<code>edi</code></p>
</blockquote>
<ol start="2">
<li>
<p>执行 <code>mov ecx,39h</code> 和 <code>mov eax,0CCCCCCCCh</code><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/No_mov_ecx_eax.png" alt="No_mov_ecx_eax" /><br />
👇👇👇<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/mov_ecx_eax.png" alt="mov_ecx_eax" /><br />
寄存器 <code>ecx</code> 存入 <code>十六进制 39(十进制 57)</code><br />
寄存器 <code>eax</code> 存入<code>0xCCCCCCCC</code></p>
</li>
<li>
<p>执行 <code>rep_stos dword_ptr_es:[edi]</code>：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/rep_stos_change.png" alt="rep_stos" /><br />
执行之后，从 <code>0x00AFF988 - 4</code> 到 <code>0x00AFF8A4</code> 的<code>(每4字节)</code>所有内容都被设置为了 <code>0xCCCCCCCC</code> ，即 开辟的<code>main</code> 栈帧中的所有内容被设置为 <code>0xCCCCCCCC</code></p>
</li>
</ol>
<blockquote>
<p>汇编指令：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lea</span>         <span class="built_in">edi</span>,[<span class="built_in">ebp</span>-<span class="number">0E4h</span>]  </span><br><span class="line"><span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="number">39h</span>  </span><br><span class="line"><span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="number">0CCCCCCCCh</span>  </span><br><span class="line"><span class="keyword">rep</span> stos    <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>]</span><br></pre></td></tr></table></figure>
<p>这一段汇编指令中最后一句<br />
<code>rep_stos dword_ptr_es:[edi]</code><br />
<code>rep</code> ： 重复上面指令， 即</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lea</span>         <span class="built_in">edi</span>,[<span class="built_in">ebp</span>-<span class="number">0E4h</span>]  </span><br><span class="line"><span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="number">39h</span>  </span><br><span class="line"><span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="number">0CCCCCCCCh</span></span><br></pre></td></tr></table></figure>
<p>寄存器 <code>ecx</code> 中的值，即为重复的次数<br />
<code>stos</code> ：将 <code>eax</code> 中的值拷贝到 <code>edi</code> 指向的地址</p>
</blockquote>
<blockquote>
<blockquote>
<p>指令执行时，默认 <code>edi</code> 中的地址，是增大的(向高地址增长)。所以，会从<code>edi [ebp-0E4h(0x00AFF8A4)]</code> 每4字节的增长，增长到 <code>0x00AFF988</code> 共 57次(寄存器 <code>ecx</code> 中存入的数据)</p>
</blockquote>
</blockquote>
<p><code>main</code> 函数栈帧中所有内容被 设置为了 <code>0xCCCCCCCC</code><br />
那么 在 <code>main</code> 函数中 定义局部变量 而不初始化<br />
局部变量就会表示随机值。<br />
所以 输出一个未初始化的局部变量，很可能会出现：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/0xCCCCCCCC.png" alt="" /></p>
</blockquote>
<p>到此，<code>main</code> 函数栈帧的预创建全部完成（只是预创建）。<br />
接下来就是，局部变量的创建、调用函数栈帧的创建、函数传参、函数返回等。</p>
<h1 id="局部变量是如何创建的调用函数究竟是如何传参的"><a class="markdownIt-Anchor" href="#局部变量是如何创建的调用函数究竟是如何传参的"></a> 局部变量是如何创建的？调用函数究竟是如何传参的？</h1>
<p>以上，详细分析了 <code>main</code> 函数栈帧在内存中创建的过程。<br />
创建完成之后，就会按照顺序执行 <code>main</code> 函数中的函数 或 语句。</p>
<p>接下来，就是局部变量在栈帧中的创建 和 函数被调用时传参的实现：</p>
<h2 id="局部变量在栈帧中的创建"><a class="markdownIt-Anchor" href="#局部变量在栈帧中的创建"></a> 局部变量在栈帧中的创建</h2>
<p>先在反汇编窗口中，右键选择显示符号名，可以看到：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Show_char_name.png" alt="字符名" /><br />
关闭字符名则会显示地址：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Local_variables_creat_front.png" alt="Local_variables_creat_front" /></p>
<blockquote>
<p><code>dword ptr</code> 表示地址内容为双字<code>(4字节)</code>数据</p>
</blockquote>
<p>观察汇编代码，对 局部变量 <code>a</code>、 <code>b</code>、 <code>c</code> 的创建及初始化是从 地址<code>ebp-8</code> 开始的。<br />
代码向下执行：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Local_variables_creat.png" alt="Local_variables_creat" /></p>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Local_variables_creat.gif" alt="Local_variables_creat" style="zoom: 60%;" />
<p>局部变量的创建相对简单，一张动图就可以理解。</p>
<h2 id="函数被调用时的传参-及-被调用函数栈帧的创建"><a class="markdownIt-Anchor" href="#函数被调用时的传参-及-被调用函数栈帧的创建"></a> 函数被调用时的传参 及 被调用函数栈帧的创建</h2>
<p>调用需要使用参数的函数时，需要传入存在的局部变量，作为函数的参数。<br />
但是，被传入函数的参数，在函数中都被称为 <code>形参</code>，在被调用函数中 直接改变 并不能真正改变原来的变量，这是为什么？</p>
<p>真正的原因，就在这里：</p>
<hr />
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Add_No.png" alt="" /><br />
先分析汇编代码：</p>
<blockquote>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span>        <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">14h</span>]</span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]</span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">ecx</span></span><br></pre></td></tr></table></figure>
<p>将 <code>ebp-14h</code> 地址处的双字的值（即变量 b 的值）存入 寄存器 <code>eax</code>，压栈存入 <code>eax</code> ，压入位置是：<code>0x00AFF894</code><br />
将 <code>ebp-8</code> 地址处的双字的值（即变量 a 的值）存入 寄存器 <code>ecx</code>，压栈存入 <code>ecx</code>，压入位置是：<code>0x00AFF890</code></p>
</blockquote>
<p>执行之后内存中的变化：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/eax_ecx_a_b_push.png" alt="形参的传参" /></p>
<p><code>这两个步骤，其实就是形参的创建，或者说调用函数时的传参操作</code><br />
<code>(被调用函数究竟是如何使用形参的内容在下边)</code><br />
也就是说，形参的创建其实是在 <code>main</code> 函数的栈帧中创建的。</p>
<p>汇编指令继续向下执行（注意：执行 <code>call</code> 指令时，<code>(VS环境)</code>按<code>F11</code> 进入函数内部 ）：</p>
<blockquote>
<p><code>call</code> 指令，在这里的作用是：</p>
<ol>
<li>将 <code>call</code> 指令的一下条指令的地址<code>(00911F00)</code>压入栈中</li>
<li>然后跳转至 后边的地址<code>(009111E0)</code>的代码处</li>
</ol>
</blockquote>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/call.png" alt="Call 指令执行" /><br />
到此时内存变化：</p>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Creat_Virtual_parameters.gif" alt="Virtual_variables_creat" style="zoom: 60%;" />
<blockquote>
<p><code>jmp</code> 指令：无条件跳转至 后边的地址处<br />
即在此指令中，跳转至<code>00911A40</code> 处</p>
</blockquote>
<p>执行 <code>jmp</code> ：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/jmp_add.png" alt="jmp Add" /></p>
<p>执行 <code>jmp</code> 之后，进入 <code>Add 函数</code>，会发现一段熟悉的指令，和进入 <code>main</code> 函数时的前几行指令相似。<br />
这段指令就是 <code>Add</code> 函数预开辟栈帧的指令（不再分析），直接看图：</p>
<ol>
<li>
<p>先压栈，压入的是 维护 <code>main</code> 函数栈帧时的<code>ebp</code>  ：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Add_ebp_Push.png" alt="Add函数压入维护main的ebp" /></p>
</li>
<li>
<p>连续执行指令，预创建及处理 <code>Add</code> 函数栈帧：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Add_SF_Creat.png" alt="Add_函数栈帧创建" /></p>
</li>
</ol>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Add_SF_Creat.gif" alt="Add_SF_Creat" style="zoom: 60%;" />
<p>以上是 <code>Add</code> 函数栈帧的创建过程。</p>
<h2 id="被调用函数形参的使用"><a class="markdownIt-Anchor" href="#被调用函数形参的使用"></a> 被调用函数形参的使用</h2>
<p>自定义的 <code>Add</code> 函数，目的是求两个<code>int</code> 类型整数的和，返回值也是 <code>int</code> 类型。</p>
<p>观察、对比汇编代码：</p>
<blockquote>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Use_Virtual_variables.png" alt="" /></p>
<ol>
<li><code>z</code> ，是在 <code>Add</code> 函数栈帧内创建的局部变量，对应的地址是 <code>ebp-8</code>，即从 <code>ebp(此时维护Add栈帧的栈底指针)</code> 向低地址偏移 <code>8 字节</code>，发现在 <code>Add</code> 栈帧内部。<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Add_Creat_VR.png" alt="" /></li>
<li><code>x</code>、<code>y</code> 分别对应 ：<code>ebp+8</code> 、<code>ebp+0Ch</code><br />
即从 <code>ebp</code> 向高地址偏移 <code>8 字节</code> 和 <code>12 字节</code>，很明显不在 <code>Add</code> 函数栈帧内，究竟在哪？<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Add_VR_address.png" alt="" /><br />
分析之后发现，<code>Add</code> 函数调用的形参 其实就是之前(即将进入<code>Add</code>函数时)，执行这一段代码时压栈的内容：</li>
</ol>
<blockquote>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span>        <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">14h</span>]</span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]</span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">ecx</span></span><br></pre></td></tr></table></figure>
<p>将 <code>ebp-14h</code> 地址处的双字的值（即变量 <code>b</code> 的值）存入 寄存器 <code>eax</code>，压栈存入 <code>eax</code>，压入位置是：<code>0x00AFF894</code><br />
将 <code>ebp-8</code> 地址处的双字的值（即变量 <code>a</code> 的值）存入 寄存器 <code>ecx</code>，压栈存入 <code>ecx</code>，压入位置是：<code>0x00AFF890</code></p>
</blockquote>
<ol start="3">
<li>所以<br />
<code>函数的形参其实早在main函数栈帧中就已经创建好并且存储在一个位置，并不是进入函数才创建的，函数要使用形参直接在存储的那个地址拿就可以了，这就是 在函数中改变形参不会影响原变量 的原因</code></li>
</ol>
</blockquote>
<p>观察过后，执行相加的语句：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Add.png" alt="" /><br />
相加操作完成。<br />
但是需要将相加的结果作为返回值返回，并且重新回到<code>main</code> 函数中，这个函数才算执行结束。</p>
<p>返回操作具体是如何进行的呢？</p>
<h2 id="函数返回"><a class="markdownIt-Anchor" href="#函数返回"></a> 函数返回</h2>
<p>函数返回并没有看上去那么简单：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Return_Add.png" alt="" /><br />
<code>return z;</code> 语句之后，其实都是函数返回需要进行的操作。</p>
<ol>
<li>
<p>首先是，<code>return z;</code><br />
返回值操作是，<code>mov eax,dword ptr [ebp-8]</code><br />
将 <code>ebp-8(z)</code> 处的两字<code>(4字节)</code> 的值存入 寄存器 <code>eax</code><br />
返回 <code>z</code> 的操作，其实就是将 <code>z</code> 的值，存入了寄存器中。<br />
当函数使用完后，局部变量会被销毁，但是寄存器在CPU中是不会被销毁的。<br />
所以将 局部变量 <code>z</code> 的值 存放在寄存器中，就能达到返回 <code>z</code> 的值 的效果。<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/return_z.png" alt="return_z" style="zoom: 60%;" /></p>
</li>
<li>
<p>再按顺序将:<br />
在进入 <code>Add</code> 函数后 压栈的 <code>edi</code>, <code>esi</code>, <code>ebx</code> 三个内容退栈<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Add_pop_edi_esi_ebx.png" alt="pop_edi_esi_ebx" style="zoom: 60%;" /></p>
</li>
<li>
<p>然后将 <code>ebp</code> 的值 给 <code>esp</code><br />
当 <code>esp</code> 的值变为 <code>ebp</code> 的值的时候，<code>Add</code> 函数栈帧的维护就结束了。<code>Add</code> 函数栈帧的空间就会还给内存。<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/mov_esp%2Cesp.png" alt="mov_esp,esp" style="zoom: 60%;" /></p>
</li>
<li>
<p>再然后就是 <code>pop ebp</code><br />
<code>pop ebp</code>  与 一般 <code>pop</code> 其他内容不同，<code>pop ebp</code> 还会将这里需要弹出的 <code>ebp</code> 的值 给 寄存器 <code>ebp</code><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/pop_ebp.png" alt="pop_ebp" style="zoom: 60%;" /><br />
此时，<code>esp</code> 和 <code>ebp</code> 两个维护栈帧的寄存器，就又去维护 <code>main</code> 函数栈帧了。</p>
</li>
</ol>
<p>这整个过程的动画：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Destory_Add_SF.gif" alt="" /></p>
<ol start="5">
<li>最后一步就是 <code>ret</code> 指令<br />
当 <code>Add</code> 函数使用结束之后，汇编代码应该继续回到 <code>main</code> 函数中的 <code>call</code> 指令的下一条语句的地方：<br />
即这里：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/return_call.png" alt="return 应该回到的位置" /><br />
那么怎么才能回到这里呢？<br />
回想一下，在 <code>esp</code> 和 <code>ebp</code> 重新维护<code>main</code> 函数栈帧的时候，<code>esp</code> 指向的地址，其实就是之前 <code>call</code> 指令执行时，压栈压入的 <code>call</code> 指令的下一条指令的地址:<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/ret_address.png" alt="ret的地址" /><br />
<code>ret</code> 指令执行之后，会直接把这个空间弹出栈，然后返回到这个空间存放的地址的指令处：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/ret.gif" alt="ret" style="zoom: 60%;" /><br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/ret_after.png" alt="返回main函数" /></li>
</ol>
<p>这些步骤执行之后，逻辑成功从 <code>Add</code> 函数中返回到 <code>main</code> 函数中。</p>
<p>继续执行代码：<br />
<code>add esp,8</code>:<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/add_esp.png" alt="esp+8" /></p>
<p><code>mov dword ptr [ebp-20h],eax</code>:</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/mov_eax_to_c.png" alt="" /></p>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/esp%2B8_mov_c.gif" alt="" style="zoom: 60%;" />
<p>代码走到这里，函数栈帧的大部分内容都已经讲的很清楚了。本篇文章到这里也就结束了。</p>
<hr />
<h1 id="结束"><a class="markdownIt-Anchor" href="#结束"></a> 结束</h1>
<p>再回过头来看文章开头的问题：</p>
<blockquote>
<ol>
<li>什么是函数栈帧？</li>
</ol>
</blockquote>
<ol start="2">
<li>程序中的局部变量，是如何创建的？</li>
<li>为什么局部变量不初始化会是随机值？</li>
<li>函数传参，究竟是如何传参的？</li>
<li>函数的形参和实参存在什么关系？</li>
<li>函数是如何被调用的？</li>
<li>函数被调用之后是如何返回的？</li>
</ol>
<p>如果读懂了本篇文章，对于这些问题应该是有一个清晰明确的理解的。<br />
希望可以帮到大家。</p>
<hr />
<p>这篇文章，是提升自我修养篇的第一篇文章。<br />
文章的内容主要来源于 <code>《程序员的自我修养----“链接、装载与库”》</code> 以及 博主自己的调试与总结。</p>
<p>感谢！！！<br />
（画图真的耗时间）</p>
]]></content>
      <categories>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>栈帧</tag>
      </tags>
  </entry>
  <entry>
    <title>【神秘海域】[动图] 掌握 单链表 只需要这篇文章~ 「超详细」</title>
    <url>/posts/Single-List.html</url>
    <content><![CDATA[<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/List_cover.png" alt="" /></p>
<hr />
<h1 id="单链表引言"><a class="markdownIt-Anchor" href="#单链表引言"></a> 单链表引言🐙</h1>
<p>❤️‍🔥</p>
<blockquote>
<p>数据结构中有 <code>四大基础结构</code> ，即 <code>四大线性表</code>：顺序表、<strong><code>链表👻</code></strong> 、栈、队列</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th style="text-align:left">线性结构</th>
<th style="text-align:left">逻辑结构图示：</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">顺序表</td>
<td style="text-align:left"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SeqList_photo.jpg" style="zoom:50%;" /></td>
</tr>
<tr>
<td style="text-align:left"><strong><code>链表</code></strong></td>
<td style="text-align:left"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/List_photo.jpg" style="zoom:50%;" /></td>
</tr>
<tr>
<td style="text-align:left">栈</td>
<td style="text-align:left"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Stack_photo.jpg" style="zoom:50%;" /></td>
</tr>
<tr>
<td style="text-align:left">队列</td>
<td style="text-align:left"><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Queue_photo.jpg" style="zoom:50%;" /></td>
</tr>
</tbody>
</table>
</blockquote>
<p>上一篇文章的内容是：<code>顺序表</code>，从上一篇文章 可以看出 <code>顺序表</code> 存在非常明显的缺点：</p>
<ol>
<li><code>前插</code>、<code>前删</code>操作 的时间复杂度为 <code>O(N)</code></li>
<li>需要增容，增容过程比较消耗资源<code>（需要开辟新空间，拷贝数据，释放旧空间等）</code></li>
<li>增容一般是呈2倍的增长，势必会有一定的空间浪费。<code>（例如：当前容量为100，满了以后增容到200，但是只继续插入了5个数据，后面不再使用，那么就浪费了95个数据空间）</code></li>
</ol>
<p>为了解决以上的问题，又提出了一种新的数据结构：<strong><code>链表</code></strong><br />
本篇文章将详细介绍 <strong><code>链表</code></strong> 中 <strong><code>单链表</code></strong> 的 <code>结构</code>、 <code>增</code>、 <code>删</code>、 <code>查</code>、 <code>改</code>、 <code>插入</code> 等操作。</p>
<hr />
<h1 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表🐙</h1>
<p>❤️‍🔥</p>
<h2 id="链表的分类"><a class="markdownIt-Anchor" href="#链表的分类"></a> 链表的分类🪸</h2>
<p>❤️‍🔥<br />
上面展示的链表结构是单链表，其实链表有许多不同的结构：</p>
<blockquote>
<ol>
<li>单链表<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SList_show1_4_19.png" alt="" /></li>
<li>双向链表<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/double_List_show_4_19.png" alt="" /></li>
<li>带头结点的单链表<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/head_SList_show1_4_19.png" alt="" /></li>
<li>带头结点的双向链表<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/head_double_List_show_4_19.png" alt="" /></li>
<li>循环单链表<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/head_cycle_SList_show1_4_19.png" alt="" /></li>
<li>循环双向链表<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/double_cycle_List_show_4_19.png" alt="" /></li>
<li>带头结点的单向循环链表<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/head_cycle_SList_show_4_19.png" alt="" /></li>
<li>带头结点的双向循环链表<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/head_double_cycle_List_show_4_19.png" alt="" /></li>
</ol>
</blockquote>
<p>链表的结构有这 <code>八</code> 种，但是大部分都是不常用的。<br />
常用的链表结构只有两种：</p>
<ol>
<li><code>不带头节点的单向非循环链表</code></li>
<li><code>带头节点的双向循环链表</code></li>
</ol>
<blockquote>
<p><code>【神秘海域】数据结构与算法</code> 系列，也只会着重介绍这 <code>两种链表结构</code> ，简单来说只要掌握了这两种链表结构，其他的链表结构就应该都不成问题</p>
</blockquote>
<p>本篇文章介绍的内容就是 <code>不带头节点的单向非循环链表</code>，一般直接被称为 <code>单链表👻</code></p>
<h2 id="单链表的结构"><a class="markdownIt-Anchor" href="#单链表的结构"></a> 单链表的结构🪸</h2>
<p>❤️‍🔥</p>
<blockquote>
<p><code>单链表的结构</code> 非常的简单，在实际的使用中，单链表一般作为更高级数据结构的子结构来使用。</p>
</blockquote>
<p>引言的表中，简单表示了 <code>单链表的结构</code> ：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/List_photo.jpg" style="zoom:50%;" /><br />
是有一个一个节点链接在一起形成的，不过这只是逻辑结构，逻辑顺序是通过 <code>链表中的指针链接次序</code> 实现的，而实际的链表是一种 物理存储结构上 <code>非连续、非顺序</code> 的存储结构，即 这些 <code>单个的节点在内存中不一定是连续存放的</code> 。</p>
<p>详细的实际情况应该是这样的：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SList_show_4_19.png" alt="" /><br />
即：单链表在 <code>逻辑上是连续的</code> ，一个连着一个，但是在 <code>物理结构上是不一定连续的</code> 。<br />
而且可以看出，单链表中 <code>单个节点的结构</code> 由一个 <code>数据单元(存放数据)</code> 和一个 <code>指针单元(存放下个节点的地址)</code> 构成。这样可以保证 链表可以向后链接。</p>
<p>所以 <code>单链表结构中单个节点</code> 的代码就应该包括两个部分：<code>数据</code> 和 <code>next指针</code><br />
实现就为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLTDataType;        <span class="comment">// int typedef 为 SLTDataType</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表(SingleList)结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SLTDataType val;               <span class="comment">// val 用来存放数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span>* <span class="title">next</span>;</span>       <span class="comment">// next 存放下一节点地址，用来指向下一节点 </span></span><br><span class="line">&#125;SListNode;</span><br></pre></td></tr></table></figure>
<p>这就是单链表一个节点的结构。</p>
<h2 id="单链表接口及实现"><a class="markdownIt-Anchor" href="#单链表接口及实现"></a> 单链表接口及实现🪸</h2>
<p>❤️‍🔥</p>
<p><code>链表</code> 与 <code>顺序表</code> 一样，几乎所有的操作都是由一个个 <code>接口函数</code> 来完成的。</p>
<p>但是，链表 是由一个个<code>单独的节点</code>连接起来而构成的，而顺序表本质上是 一个<code>数组</code>。</p>
<p>所以对于链表的接口，首先需要一个 <code>申请单独节点的接口函数</code> ，然后再进行其他的操作<br />
即，一般 <code>单链表的接口函数</code> 有：</p>
<ol>
<li>新申请节点：<code>BuySLTNode</code></li>
<li>单链表打印：<code>SListPrint</code></li>
<li>单链表尾插：<code>SListPushBack</code></li>
<li>单链表头插：<code>SListPushFront</code></li>
<li>单链表尾删：<code>SListPopBack</code></li>
<li>单链表头删：<code>SListPopFront</code></li>
<li>单链表查找：<code>SListPushBack</code></li>
<li>单链表插入：<code>SListPushFront</code></li>
<li>单链表删除：<code>SListPushBack</code></li>
<li>单链表销毁：<code>SListPushFront</code></li>
</ol>
<p>先从新节点申请开始。</p>
<h3 id="新节点申请"><a class="markdownIt-Anchor" href="#新节点申请"></a> 新节点申请🐚</h3>
<p>❤️‍🔥<br />
单链表节点的申请，实现的功能一般是<br />
创建一个 <code>新的节点指针</code> ，然后将 <code>节点指针作为返回值</code> 返回到 <code>需要使用的此节点的地方</code></p>
<p>既然需要返回，那么就必然需要用动态开辟来实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SListNode* <span class="title function_">BuySLTNode</span><span class="params">(SLTDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* newNode = (SListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SListNode));</span><br><span class="line">	<span class="keyword">if</span>(newNode == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;BuyNode fail.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// malloc 成功</span></span><br><span class="line">	newNode-&gt;val = x;            <span class="comment">// 将新节点val 赋予 x</span></span><br><span class="line">	newNode-&gt;next = <span class="literal">NULL</span>;        <span class="comment">// 将新节点的next 指向空</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> newNode;              <span class="comment">// 返回新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回接收后，就可以使用新的节点。</p>
<h3 id="单链表尾插"><a class="markdownIt-Anchor" href="#单链表尾插"></a> 单链表尾插🐚</h3>
<p>❤️‍🔥<br />
单链表尾插就是在 <code>链表的尾节点之后</code> 插入节点</p>
<p>那么思考一下，尾插都需要实现什么功能：</p>
<ol>
<li>需要申请 <code>存放有指定数据</code> 的新节点</li>
<li>需要将新节点 <code>链接到链表的末尾</code></li>
</ol>
<p>功能有了，那就来实现一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SListPushBack</span><span class="params">(SListNode* phead, SLTDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pnode);</span><br><span class="line">	</span><br><span class="line">	SListNode* newNode = BuyNode(x);</span><br><span class="line">	</span><br><span class="line">	SListNode* tail = phead;        <span class="comment">//记录首节点</span></span><br><span class="line">	<span class="keyword">while</span>(tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;<span class="comment">// 从首节点开始找尾</span></span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 退出循环就代表找到尾节点</span></span><br><span class="line">	tail-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码实现完毕，尾插来验证一下。<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListPushBack_returnError.png" alt="" /></p>
<p>但是发现，程序非正常结束了。为什么？<br />
<code>调试！</code></p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListPushBack_Debug1.png" alt="" /><br />
但是当我继续 <code>F10</code> 希望进入循环时：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListPushBack_Debug2.png" alt="" /><br />
发生了访问冲突。<br />
为什么发生了访问冲突？</p>
<p><code>分析!</code></p>
<blockquote>
<p>分析过程：<br />
首先看一下进入循环的条件是什么：<br />
<code>while(tail-&gt;next != NULL)</code><br />
当前的 <code>tail</code> 是什么：<br />
<code>tail == phead == NULL</code><br />
破案了<br />
当前的 <code>tail == NULL</code> ， <code>tail</code> 根本就没有 <code>next</code> ，如果对 <code>tail-&gt;next</code> 进行访问 可不就是访问冲突吗？<br />
看来<code>刚才写的代码考虑的不全面</code></p>
</blockquote>
<p>那么就来分析一下，有什么问题没有考虑到：<br />
<code>tail</code> 为空，说明了什么问题？<br />
<code>tail</code> 是首节点的记录，<code>tail</code> 为空就代表传过来的 <code>首节点为空</code><br />
也就是说，当前 <code>链表中没有一个节点</code></p>
<p>看来是这种情况<code>(当插入的节点是链表的首节点)</code>没有考虑到<br />
那就再分析一下这种情况怎么解决</p>
<ol>
<li>首先，当 <code>phead</code> 为空时，应该单独判断<br />
如果 <code>phead == NULL</code> ，<code>首节点</code> 就应该更变为 <code>需要插入的这个新节点</code></li>
<li>这样的操作更改了传入的参数，那么就又引发了另外一个问题<br />
<code>改变形参是不改变原值的</code>，但是又需要 <code>改变原值</code>，所以形参应该传入 <code>首节点的地址</code> ，通过地址改变原值</li>
</ol>
<p>OK，现在情况应该考虑完整了</p>
<p>再来重新实现代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表尾插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPushBack</span><span class="params">(SListNode** pphead, SLTDataType x)</span></span><br><span class="line">&#123;<span class="comment">// 传首节点指针 的地址，要用**</span></span><br><span class="line">	assert(pphead);				<span class="comment">// 断言 首节点指针的地址不为空</span></span><br><span class="line"></span><br><span class="line">	SListNode* newNode = BuySLTNode(x);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 首节点为空，将新节点变为首节点</span></span><br><span class="line">	<span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*pphead = newNode;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首节点不为空就 找尾</span></span><br><span class="line">	SListNode* tail = *pphead;        <span class="comment">//记录首节点</span></span><br><span class="line">	<span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;<span class="comment">// 从首节点开始找尾</span></span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 退出循环就代表找到尾节点</span></span><br><span class="line">	tail-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListPushBack_Debug3.png" alt="" /></p>
<p>多尾插几个数据试验一下：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListPushBack_Debug4.png" alt="" /></p>
<p>这样就没问题了~</p>
<h3 id="单链表打印"><a class="markdownIt-Anchor" href="#单链表打印"></a> 单链表打印🐚</h3>
<p>❤️‍🔥<br />
实现了 <code>尾插</code> 之后，如果每次查看数据都需要 <code>调试</code> 然后 <code>监视</code>，也太麻烦了</p>
<p>所以一般需要实现一个打印函数，打印函数没有那么多的注意点</p>
<p>实现一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPrint</span><span class="params">(SListNode* phead)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* cur = phead;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;<span class="comment">// cur 为空时退出循环</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, cur-&gt;val);</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印刚才实现的单链表：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListPrint_Show.png" alt="" /></p>
<h3 id="单链表尾删"><a class="markdownIt-Anchor" href="#单链表尾删"></a> 单链表尾删🐚</h3>
<p>❤️‍🔥<br />
实现过 <code>尾插</code> 和 <code>打印</code><br />
再实现一下 <code>尾删</code></p>
<p>因为 <code>尾删</code> 也是改变 <code>单链表节点</code> 的函数，当删除链表 <code>最后一个节点</code> 的时候 也是需要改变 <code>原值</code> 的，所以传参也需要 <code>传入首节点指针的地址</code></p>
<p>而且，因为单链表 <code>只能从前向后找，不能从后向前找</code>，所以如果要删除尾节点，当前位置需要处于 <code>尾节点的前一节点</code>，或者可以保存<code>尾节点的前一节点</code>。</p>
<blockquote>
<p>如果需要 <code>控制当前节点在尾节点的前一节点停下</code> ，就需要 用 <code>cur-&gt;next-&gt;next != NULL</code> 作找尾循环条件<br />
但是这样需要保证 链表至少有<code>两个节点</code> ，所以 <code>空链表</code> 和 <code>只有一个节点的链表</code> 需要单独控制</p>
</blockquote>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表尾删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPopBack</span><span class="params">(SListNode** pphead)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pphead);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空链表</span></span><br><span class="line">	<span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只有一个节点</span></span><br><span class="line">	<span class="keyword">if</span> ((*pphead)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(*pphead);</span><br><span class="line">		*pphead = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 多个节点</span></span><br><span class="line">	SListNode* cur = *pphead;</span><br><span class="line">	<span class="keyword">while</span> (cur-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 退出循环时，cur即在尾节点的前一节点处</span></span><br><span class="line">	<span class="built_in">free</span>(cur-&gt;next);			<span class="comment">// 释放cur的next节点(尾节点)</span></span><br><span class="line">	cur-&gt;next = <span class="literal">NULL</span>;			<span class="comment">// cur-&gt;next 指向空</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 或者用前后指针的方法，将 cur 的前一个节点存储起来</span></span><br><span class="line"><span class="comment">	SListNode* prev = NULL;</span></span><br><span class="line"><span class="comment">	SListNode* cur = *pphead;</span></span><br><span class="line"><span class="comment">	while(cur-&gt;next != NULL)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		prev = cur;				// 每次进入循环先将 cur 用prev存储起来</span></span><br><span class="line"><span class="comment">		cur = cur-&gt;next;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	//退出循环时，cur是尾节点，prev是尾节点的前一个节点</span></span><br><span class="line"><span class="comment">	free(cur);					// 释放尾节点</span></span><br><span class="line"><span class="comment">	prev-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">	cur = NULL;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证一下 <code>尾删</code> 有没有出错：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListPopBack.png" alt="" /></p>
<p>即使过多次尾删也能成功</p>
<hr />
<p><code>尾插</code> 和 <code>尾删</code> 实现过后，发现一个问题</p>
<p><code>插入 和 删除 都需要从头开始找尾，这时间复杂度不还是 O(N) 吗？</code><br />
是的，单链表 <code>尾插</code> 和 <code>尾删</code> 的时间复杂度是 <code>O(N)</code><br />
所以，对于单链表的 <code>插入删除操作</code> ，一般不用 <code>尾插</code> 和 <code>尾删</code><br />
而是使用 <code>头插</code> 和 <code>头删</code></p>
<p>下面就实现一下 <code>头插</code> 和 <code>头删</code></p>
<h3 id="单链表头插"><a class="markdownIt-Anchor" href="#单链表头插"></a> 单链表头插🐚</h3>
<p>❤️‍🔥<br />
相较于单链表的尾插，<code>单链表头插</code> 的逻辑就简单得多了：</p>
<ol>
<li>创建一个新的节点</li>
<li>将新节点置于链表的头</li>
<li>再将这个新节点设置为链表首节点</li>
</ol>
<p>只需要这三步就可以了，甚至不需要考虑链表是否存在节点。</p>
<p>因为需要修改 <code>链表的首节点</code> 所以传参还需要使用 <code>二级指针</code></p>
<p><code>单链表头插的实现：</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表头插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPushFront</span><span class="params">(SListNode** pphead, SLTDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pphead);</span><br><span class="line"></span><br><span class="line">	SListNode* newNode = BuySLTNode(x);</span><br><span class="line">	newNode-&gt;next = *pphead;            <span class="comment">// 新节点的next 指向 *pphead</span></span><br><span class="line">	*pphead = newNode;                <span class="comment">// 将新节点置为 *pphead</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头插几个数据测试一下：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListPushFront_2022420.png" alt="" /><br />
<code>没有错误！</code></p>
<p>动画过程：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SingleListPushFront_20220420.gif" alt="" /></p>
<h3 id="单链表头删"><a class="markdownIt-Anchor" href="#单链表头删"></a> 单链表头删🐚</h3>
<p>❤️‍🔥<br />
头删就 <code>不像头插一样不需要考虑链表是否存在节点了</code> ，毕竟如果链表中没有节点，也删除不了</p>
<p>所以 <code>头删需要考虑链表是否为空</code><br />
并且由于 <code>单链表后找不到前</code>，且首节点是必须要释放掉的，所以 <code>首节点</code> 或者 <code>第二节点</code> 需要存起来一个。</p>
<p>那么头删的逻辑应该是什么呢？</p>
<ol>
<li>判断链表是否为空</li>
<li>链表不空：
<ol>
<li>将 <code>首节点</code> 存起来，然后将 <code>首节点的next</code> 置为 <code>*pphead</code>，然后释放 <code>首节点</code></li>
<li>将 <code>第二节点</code> 存起来，然后将 <code>首节点</code> 释放，然后释放 <code>第二节点</code> 置为 <code>*pphead</code>。</li>
</ol>
</li>
</ol>
<p>两种思路都实现一下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表头删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPopFront</span><span class="params">(SListNode** pphead)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pphead);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存首节点</span></span><br><span class="line">	SListNode* tail = *pphead;</span><br><span class="line">	*pphead = tail-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(tail);</span><br><span class="line">	tail = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存第二节点</span></span><br><span class="line">	<span class="comment">/*SListNode* tail = (*pphead)-&gt;next;</span></span><br><span class="line"><span class="comment">	free(*pphead);</span></span><br><span class="line"><span class="comment">	*pphead = tail;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头删检测：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListPopFront_2022420.png" alt="" /></p>
<p>动画过程：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SingleListPushFront_20220421.gif" alt="" /></p>
<hr />
<p>实现了 <code>头插</code> 和 <code>头删</code> 之后，能够发现<br />
<code>头删</code> 和 <code>头插</code> 操作不需要找尾，直接<code>在链表头进行操作</code> 就可以，所以时间复杂度是<code>O(1)</code><br />
比 <code>尾插</code> <code>尾删</code> 的时间复杂度快的多，所以对于单链表的 <code>插入删除</code> 一般采用 <code>头插</code> 和 <code>头删</code></p>
<h3 id="单链表查找"><a class="markdownIt-Anchor" href="#单链表查找"></a> 单链表查找🐚</h3>
<p>❤️‍🔥<br />
单链表的查找，其实是 <code>查找某个值节点</code><br />
找到数据之后返回 <code>节点</code></p>
<p>不需要修改，不需要添加，只需要比较<br />
所以，传参只需要 <code>传一级指针</code></p>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SListNode* <span class="title function_">SListFind</span><span class="params">(SListNode* phead, SLTDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* tail = phead;    <span class="comment">// 记录首节点</span></span><br><span class="line">	<span class="keyword">while</span>(tail != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;<span class="comment">// tail不为空 进循环后 再进行判断</span></span><br><span class="line">		<span class="keyword">if</span>(tail-&gt;val == x)</span><br><span class="line">			<span class="keyword">return</span> tail;        <span class="comment">// 找到就返回节点</span></span><br><span class="line">			</span><br><span class="line">		tail = tail-&gt;next;      <span class="comment">// 没找到，tail 就变为 自己的 next</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">// 没进入循环或者从循环出来了，就代表没找到，返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证一下：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SLTFind_SHOW_2022420.png" alt="" /></p>
<h3 id="单链表指定位置之后插入"><a class="markdownIt-Anchor" href="#单链表指定位置之后插入"></a> 单链表指定位置之后插入🐚</h3>
<p>❤️‍🔥<br />
单链表的 <code>插入函数</code> 一般是与单链表 <code>查找函数</code> 一起使用的<br />
<code>查找函数先找到节点的位置</code> ，然后 <code>传入插入函数在结点之后插入新的节点</code></p>
<p>单链表的 <code>插入函数的功能</code>，一般实现 <code>在传入的节点之后</code> 插入新的节点</p>
<blockquote>
<p>思考一下为什么一般不在指定节点位置之前插入?</p>
</blockquote>
<p>在 <code>指定位置(pos)之后</code> 插入新节点，就可以不用传入 <code>首节点</code> 直接将新节点 <code>链接在 pos 位置之后</code> 就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SListInsertAfter</span><span class="params">(SListNode *pos, SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pos);</span><br><span class="line"></span><br><span class="line">	SListNode *newNode = BuySLTNode(x);</span><br><span class="line">    newNode-&gt;next = pos-&gt;next;             <span class="comment">// 先将新节点的next 链上 pos的next</span></span><br><span class="line">    pos-&gt;next = newNode;            <span class="comment">// 再将pos的next指向新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证一下：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListInsertAfter_Show_2022420.png" alt="" /><br />
插入成功</p>
<p>且，在 <code>pos位置之后</code> 插入的时间复杂度为 <code>O(1)</code></p>
<p>动画过程：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SingleListErase_20220421.gif" alt="" /></p>
<h3 id="单链表指定位置之后删除"><a class="markdownIt-Anchor" href="#单链表指定位置之后删除"></a> 单链表指定位置之后删除🐚</h3>
<p>❤️‍🔥</p>
<p>与 <code>指定位置之后插入</code> 相同，<code>指定位置之后删除函数</code> 一般也是与查找函数一起使用</p>
<blockquote>
<p>同样思考一下<br />
单链表为什么 不直接删除指定位置节点呢？</p>
</blockquote>
<p>因为 <code>删除 pos 位置之后</code> 的节点，所以也不需要传入 <code>首节点指针</code><br />
所以，它的时间复杂度 也是 <code>O(1)</code></p>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表删除(pos之后)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListEraseAfter</span><span class="params">(SLTNode* pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pos);</span><br><span class="line"></span><br><span class="line">	SListNode* next = pos-&gt;next;			<span class="comment">//先记录 pos 的 next 节点</span></span><br><span class="line">	<span class="keyword">if</span> (next)</span><br><span class="line">	&#123;<span class="comment">// 若此节点不为空则进行操作</span></span><br><span class="line">		pos-&gt;next = next-&gt;next;			<span class="comment">// 先将 pos的next 指向 next的next</span></span><br><span class="line">		<span class="built_in">free</span>(next);						<span class="comment">// 再释放 next</span></span><br><span class="line">		next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListEraseAfter_Show_2022421.png" alt="" /></p>
<p>动画过程：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SingleListEraseAfter_20220421.gif" alt="" /></p>
<h3 id="单链表的销毁"><a class="markdownIt-Anchor" href="#单链表的销毁"></a> 单链表的销毁🐚</h3>
<p>❤️‍🔥<br />
对于单链表的销毁，需要注意的点不多：</p>
<ol>
<li>销毁是从首节点开始的</li>
<li>销毁当前结点之前，要将下一节点存储起来，防止找不到链表</li>
<li>因为销毁需要改变首节点，所以需要传入二级指针</li>
<li>销毁完成之后，<code>*pphead</code> 置空</li>
</ol>
<p>经过以上接口的实现，考虑完这些点，就可以直接实现 <code>销毁</code> 了:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁单链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListDestroy</span><span class="params">(SListNode** pphead)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pphead);</span><br><span class="line">	</span><br><span class="line">	SListNode* tail = *pphead;</span><br><span class="line">	<span class="keyword">while</span>(tail != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;<span class="comment">// 链表不为空</span></span><br><span class="line">		SListNode* next = tail-&gt;next;    <span class="comment">//销毁当前结点之前,要将下一节点存储起来</span></span><br><span class="line">		<span class="built_in">free</span>(tail);</span><br><span class="line">		tail = next;                <span class="comment">// 将tail 赋成 存储起来的节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	*pphead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/SListDestroy_2022420.png" alt="" /></p>
<p>单链表成功被销毁。</p>
<hr />
<p>单链表 <code>主要接口</code> 的实现就是这些了<br />
需要注意的 <code>细节</code> 有很多，但都不是什么大问题</p>
<p>重新回到那个问题：</p>
<ol>
<li>为什么插入不在 <code>pos</code> 位置之前？</li>
<li>为什么删除不直接删除 <code>pos</code> 位置</li>
<li>可以实现吗？为什么不实现？</li>
</ol>
<h3 id="pos-位置插入删除的问题补充"><a class="markdownIt-Anchor" href="#pos-位置插入删除的问题补充"></a> pos 位置插入删除的问题(补充)🐚</h3>
<p>❤️‍🔥<br />
实现 <code>指定位置之后插入、删除</code> 时，可以非常简单的计算出，这两个接口时间复杂度都是 <code>O(1)</code></p>
<p>如果是在 <code>指定位置之前插入、删除</code> 呢？<br />
那么，时间复杂度就换变成 <code>O(N)</code></p>
<p>由于单链表 <code>只能从前找后，不能从后找前</code> ，所以如果想要操作 <code>pos</code> 位置之前的节点，就需要先 <code>从首节点位置向后找，直到找到 pos 之前的节点</code>，才能依此基础进行操作</p>
<p>这个过程与 <code>单链表尾插、尾删</code> 非常的相似，都需要找尾，所以时间复杂度就来到了 <code>O(N)</code> 这个级别。</p>
<p>所以，对于单链表 <code>pos位置的插入、删除</code> ，一般都是在 <code>pos</code> 位置之后</p>
<hr />
<blockquote>
<p>可以自己手动写一写，在 <code>pos</code> 位置之前插入、删除的接口</p>
</blockquote>
<h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语🐙</h1>
<p>❤️‍🔥<br />
本篇文章所介绍实现的是 <code>线性表结构</code> 之一的：<code>单链表</code>。<br />
是一个完全不同于 <code>顺序表</code> 的数据结构，接口实现 需要注意的细节也有很多，比如 <code>首节点</code> 什么时候需要变化，接口什么时候 传参传入 <code>二级指针</code>。</p>
<p>好了，本篇文章， <code>【神秘海域】 数据结构与算法</code> 系列的第三篇 <code>单链表篇</code> ，至此结束。</p>
<p>感谢阅读！！</p>
<hr />
]]></content>
      <categories>
        <category>神秘海域：数据结构与算法</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构与算法</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title>【C 语言】[图文] 详解结构体，详细分析结构体对齐</title>
    <url>/posts/Structure.html</url>
    <content><![CDATA[<h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h1>
<h2 id="1-结构体"><a class="markdownIt-Anchor" href="#1-结构体"></a> 1. 结构体</h2>
<pre><code>结构体是一些值的集合，这些值成为成员变量。结构的每个成员可以是不同类型的变量。结构体属于自定义类型。
</code></pre>
<span id="more"></span>
<h3 id="11-结构体声明"><a class="markdownIt-Anchor" href="#11-结构体声明"></a> 1.1 结构体声明</h3>
<h4 id="111-标准声明"><a class="markdownIt-Anchor" href="#111-标准声明"></a> 1.1.1 标准声明</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> Name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> Sex[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此结构体的类型就是 <code>struct User</code><br />
<code>User</code> 是结构体标签<code>(tag)</code></p>
</blockquote>
<h4 id="112-特殊声明不完全声明"><a class="markdownIt-Anchor" href="#112-特殊声明不完全声明"></a> 1.1.2 特殊声明(不完全声明)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> Name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> Sex[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;User1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> Name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> Sex[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;*p;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种声明方法省略了结构体标签<code>tag)</code>, 直接定义的 <code>User1</code> 和 <code>p</code> 均被称为<code>匿名结构体变量</code>。无法在<code>main</code> 函数中再次定义此种结构体变量<br />
并且，虽然表面上 <code>User1</code> 和 <code>*p</code>的 <code>结构体类型</code> 好像一样。</p>
<p>但是如果 <code>p = &amp;User1;</code> 进行编译，将会报出警告。警告内容是：<code>指针 到 指针 的类型不兼容</code>。说明 两个变量的结构体类型并不相同，编译器认为，<code>两个成员一样的匿名结构体类型是两种不同的类型</code></p>
</blockquote>
<h3 id="12-结构体的自引用"><a class="markdownIt-Anchor" href="#12-结构体的自引用"></a> 1.2 结构体的自引用</h3>
<p>以 链表节点 为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自引用 结构体类型的指针</span></span><br></pre></td></tr></table></figure>
<p>但是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">// 不行</span></span><br><span class="line"><span class="comment">// 结构体内部使用 Node* 时, typedef 还未生效</span></span><br></pre></td></tr></table></figure>
<h3 id="13-结构体变量的定义和初始化"><a class="markdownIt-Anchor" href="#13-结构体变量的定义和初始化"></a> 1.3 结构体变量的定义和初始化</h3>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contact</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> Addr[<span class="number">30</span>];</span><br><span class="line">    <span class="type">char</span> Tele[<span class="number">12</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 嵌套结构体的结构体声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> Name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> Sex[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Contact</span> <span class="title">C</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Contact</span> <span class="title">C1</span> =</span> &#123;<span class="string">&quot;CSDN&quot;</span>, <span class="string">&quot;2xxxxxxxxxx&quot;</span> &#125;;<span class="comment">//结构体变量的定义和初始化</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">U1</span> =</span> &#123; <span class="string">&quot;July3&quot;</span>, <span class="string">&quot;Male&quot;</span>, <span class="number">19</span>, &#123; <span class="string">&quot;CSDN&quot;</span>, <span class="string">&quot;1xxxxxxxxxx&quot;</span> &#125; &#125;;	<span class="comment">//嵌套结构体的结构体变量的定义和初始化</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-结构体内存对齐"><a class="markdownIt-Anchor" href="#14-结构体内存对齐"></a> 1.4 结构体内存对齐 *</h3>
<p>要弄明白什么是结构体内存对齐，我们先来看一下结构体大小</p>
<p>下面这段结构体的大小是多少？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们用 <code>sizeof</code> 求出此结构体类型的大小是：<code>12</code> 字节</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124135912996.png" alt="image-20220124135912996" /></p>
<p>但是 <code>int</code>类型大小是 <code>4</code> 字节，<code>char</code> 类型的大小是 <code>1</code> 字节。这个结构体大小不应该是 <code>6</code> 字节吗？ 为什么是 <code>12</code> 字节呢？</p>
<p>这就是由于内存对齐的原因：</p>
<hr />
<blockquote>
<p>在正式开始讲解什么是内存对齐之前，我们先来了解一个概念：<code>结构体成员的偏移量</code></p>
<p>什么是结构体成员的偏移量？</p>
<p>一个结构体的每个成员地址相对于其结构体类型的首地址的偏移量，就是结构体成员的偏移量。</p>
<p>怎么计算结构体成员的偏移量？</p>
<p>C语言中，计算结构体成员的偏移量有一个函数：<code>offsetof</code></p>
<blockquote>
<p><code>offsetof</code></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">offsetof</span><span class="params">( structName, memberName)</span>;</span><br></pre></td></tr></table></figure>
<p><code>offsetof</code>函数的两个参数是：结构体类型名，计算偏移量的成员名</p>
<p>所在头文件是 <code>stddef.h</code></p>
</blockquote>
<p>我们先计算一下上边这段结构体类型，各成员的偏移量(<code>%zu是输出 size_t 类型的数据的指定格式</code>)</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124141635244.png" alt="image-20220124141635244" /></p>
<p>第一个，<code>c1</code>的偏移量是 <code>0</code>;</p>
<p>其次，<code>i</code> 的偏移量是 <code>4</code>;</p>
<p>最后，<code>c2</code>的偏移量是 <code>8</code>.</p>
<p>我们做图明确出来：</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124144039803.png" alt="image-20220124144039803" style="zoom:67%;" />
<p>可以非常明显的看出，结构体成员<code>c1</code> 到 <code>i</code> 之间，有三个字节的空间是空的</p>
<p>不过，这也才占用了 <code>9</code>字节的空间，但是我们计算的 结构体的大小 是 <code>12</code>，所以我们判断，在 <code>c2</code> 之后还有三个字节的空间 被这个结构体所占用。</p>
<p>所以，此结构体的内存空间占用情况，可能是这样的：</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124144940813.png" alt="image-20220124144940813" style="zoom:67%;" />
<p>那么，为什么呢？为什么会有 开辟了，但是没有用到 的空间呢？一个结构体类型的大小，到底如何计算呢？</p>
</blockquote>
<h4 id="141-结构体内存对齐规则"><a class="markdownIt-Anchor" href="#141-结构体内存对齐规则"></a> 1.4.1 结构体内存对齐规则</h4>
<ol>
<li>
<p>结构体的第一个成员变量存放在结构体变量 开始位置的 0 偏移处</p>
</li>
<li>
<p>从第二个成员变量开始，要对齐到 某个对齐数 的整数倍的地址处</p>
<blockquote>
<p>对齐数：编译器的默认对齐数 与 该成员自身大小 的较小值</p>
<ul>
<li>VS编译器 中 对齐数默认为 8</li>
<li>如果编译器默认没有对齐数，对齐数就是成员自身大小</li>
</ul>
</blockquote>
</li>
<li>
<p>结构体总大小必须是 最大对齐数的整数倍</p>
<blockquote>
<p>最大对齐数：结构体所有成员中，对齐数最大的成员的对齐数</p>
</blockquote>
</li>
<li>
<p>如果是结构体嵌套了结构体的情况，被嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍</p>
</li>
</ol>
<p>了解了结构体内存对齐规则，就来详细了解一下结构体到底是如何内存对齐的</p>
<h4 id="142-结构体内存对齐详解"><a class="markdownIt-Anchor" href="#142-结构体内存对齐详解"></a> 1.4.2 结构体内存对齐详解</h4>
<h5 id="1421-示例1"><a class="markdownIt-Anchor" href="#1421-示例1"></a> 1.4.2.1 示例1：</h5>
<p>我们以上面举过例子的结构体为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先看一下总大小：<br />
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124160252990.png" alt="image-20220124160252990" style="zoom:67%;" /></p>
<p>然后我们具体来计算一下：</p>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">除第一个成员外的结构体成员</th>
<th style="text-align:center">成员自身大小成员自身大小(类型大小)</th>
<th style="text-align:center">编译器默认对齐数</th>
<th style="text-align:center">实际对齐数(取较小值)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>i</code></td>
<td style="text-align:center"><code>(int)</code>4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center"><code>c2</code></td>
<td style="text-align:center"><code>(char)</code>1</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>根据规则：</p>
<ol>
<li>
<p><code>c1</code> 存放在结构体变量 开始地址的 0 偏移处</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124154534873.png" alt="image-20220124154534873" style="zoom: 67%;" /> 
</li>
<li>
<p><code>i</code> 的对齐数是 <code>4</code>，所以存放在偏移量是 <code>4</code>的整数倍 处</p>
<p>至少是<code>4</code></p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124155055202.png" alt="image-20220124155055202" style="zoom:67%;" />
</li>
<li>
<p><code>c2</code> 的对齐数是 <code>1</code>，所以存放在偏移量是 <code>1</code>的整数倍 处</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124155317987.png" alt="image-20220124155317987" style="zoom:67%;" />
</li>
<li>
<p>结构体总大小必须为 最大对齐数的整数倍，在此结构体中即为 <code>4</code> 的整数倍。</p>
<p><code>c2</code>所在空间已经是 第 <code>9</code> 个字节，所以此结构体总大小 最小为 <code>12</code></p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124155736544.png" alt="image-20220124155736544" style="zoom:67%;" />
<p>所以，结构体大小为 <code>12</code> 字节</p>
</li>
</ol>
</blockquote>
<h5 id="1422-示例2"><a class="markdownIt-Anchor" href="#1422-示例2"></a> 1.4.2.2 示例2：</h5>
<p>再来看下边这个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们将，上一个结构体成员中的，<code>i</code> 和<code>c2</code>换一换位置结果又是什么呢？</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124160428100.png" alt="image-20220124160428100" style="zoom:67%;" />
<p>我们发现只是换了一下位置，结构体大小就减少了 <code>4</code> 个字节</p>
<p>这次又是怎么对齐和计算的呢？</p>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">除第一个成员外的结构体成员</th>
<th style="text-align:center">成员自身大小成员自身大小(类型大小)</th>
<th style="text-align:center">编译器默认对齐数</th>
<th style="text-align:center">实际对齐数(取较小值)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c2</code></td>
<td style="text-align:center"><code>(char)</code>1</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>i</code></td>
<td style="text-align:center"><code>(int)</code>4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<ol>
<li><code>c1</code> 存放在结构体变量 开始地址的 0 偏移处</li>
</ol>
  <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124154534873.png" alt="image-20220124154534873" style="zoom: 67%;" /> 
<ol start="2">
<li><code>c2</code> 的对齐数是 <code>1</code>，所以存放在偏移量是 <code>1</code>的整数倍 处，<code>c2</code> 下面就可以</li>
</ol>
  <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124160939391.png" alt="image-20220124160939391" style="zoom:67%;" />
<ol start="3">
<li><code>i</code> 的对齐数是 <code>4</code>，所以存放在偏移量是 <code>4</code>的整数倍 处</li>
</ol>
<p>至少是<code>4</code></p>
  <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124161026248.png" alt="image-20220124161026248" style="zoom:67%;" />
<ol start="4">
<li>结构体总大小必须为 最大对齐数的整数倍，在此结构体中即为 <code>4</code> 的整数倍。</li>
</ol>
<p><code>i</code>存放完，结构体占<code>8</code>个字节，正好是 <code>4</code>的倍数，所以不用再占用其他空间</p>
  <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124161322999.png" alt="image-20220124161322999" style="zoom:67%;" />
<p>此结构体总大小为：<code>8</code>字节</p>
</blockquote>
<h5 id="1423-示例3"><a class="markdownIt-Anchor" href="#1423-示例3"></a> 1.4.2.3 示例3：</h5>
<p>再来一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">double</span> n;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们先自己计算：</p>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">除第一个成员外的结构体成员</th>
<th style="text-align:center">成员自身大小(类型大小)</th>
<th style="text-align:center">编译器默认对齐数</th>
<th style="text-align:center">实际对齐数(取较小值)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c1</code></td>
<td style="text-align:center"><code>(char)</code>1</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>i</code></td>
<td style="text-align:center"><code>(int)</code>4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>n</code> 存放在结构体变量 开始地址的 <code>0</code> 偏移处</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124163039058.png" alt="image-20220124163039058" style="zoom:67%;" />
</li>
<li>
<p><code>c2</code> 的对齐数是 <code>1</code>，所以存放在偏移量是 <code>1</code>的整数倍 处</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124163133970.png" alt="image-20220124163133970" style="zoom:67%;" />
</li>
<li>
<p><code>i</code> 的对齐数是 <code>4</code>，所以存放在偏移量是 <code>4</code>的整数倍 处</p>
<p>至少是<code>12</code></p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124163205300.png" alt="image-20220124163205300" style="zoom:67%;" />
</li>
<li>
<p>结构体总大小必须为 最大对齐数的整数倍，在此结构体中即为 <code>8</code> 的整数倍。</p>
<p><code>i</code>存放完，结构体占<code>16</code>个字节，正好是 <code>8</code>的倍数，所以不用再占用其他空间</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124163407789.png" alt="image-20220124163407789" style="zoom:67%;" />
<p>此结构体总大小为：<code>16</code>字节</p>
</li>
</ol>
</blockquote>
<p>我们来验证一下：</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124163820717.png" alt="image-20220124163820717" style="zoom:67%;" />
<p>确实跟我们计算的一样，这个结构体大小为 <code>16</code> 字节</p>
<h5 id="1424-示例4嵌套结构体的结构体"><a class="markdownIt-Anchor" href="#1424-示例4嵌套结构体的结构体"></a> 1.4.2.4 示例4（嵌套结构体的结构体）</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">double</span> n;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S3</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么嵌套有结构体的结构体<code>S4</code>，它的成员怎么去对齐，它的大小怎么计算呢？</p>
<p>按照内存对齐的规则：</p>
<blockquote>
<p>如果是结构体嵌套了结构体的情况，被嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍</p>
</blockquote>
<p>被嵌套的结构体的对齐数，就是它的 对齐数最大的成员 的对齐数</p>
<p>所以，我们先来计算：</p>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">除第一个成员外的结构体成员</th>
<th style="text-align:center">成员自身大小(类型大小)</th>
<th style="text-align:center">对齐数最大的成员的对齐数</th>
<th style="text-align:center">编译器默认对齐数</th>
<th style="text-align:center">实际对齐数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>s</code></td>
<td style="text-align:center"><code>(struct S3)</code>16</td>
<td style="text-align:center"><code>(double)</code>8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center"><code>c1</code></td>
<td style="text-align:center"><code>(char)</code>1</td>
<td style="text-align:center"></td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>n</code> （大小为<code>4</code>）存放在结构体变量 开始地址的 <code>0</code> 偏移处</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124165613737.png" alt="image-20220124165613737" style="zoom:67%;" />
</li>
<li>
<p><code>s</code> （大小为<code>16</code>）的对齐数是 <code>8</code>，所以存放在偏移量是 <code>8</code>的整数倍 处</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124170021927.png" alt="image-20220124170021927"  />
</li>
<li>
<p><code>c1</code>（大小为 <code>1</code>）的对齐数是 <code>1</code>，所以存放在偏移量是 <code>1</code>的倍数 处</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124170223547.png" alt="image-20220124170223547" /></p>
</li>
<li>
<p>结构体总大小必须为 最大对齐数的整数倍，在此结构体中即为 <code>8</code> 的整数倍。</p>
<p><code>c1</code> 存放完，已经占用 <code>25</code> 字节，所以此结构体总大小 最小为 <code>32</code></p>
<p>即</p>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124170531153.png" alt="image-20220124170531153" style="zoom:67%;" />
<p>此结构体总大小为：<code>32</code> 字节</p>
</li>
</ol>
</blockquote>
<p>举过 4 个例子之后，结构体的内存对齐应该就已经解释清楚了</p>
<p>不过，我们再来总结一下规则：</p>
<blockquote>
<ol>
<li>
<p>结构体的第一个成员，就存放在结构体偏移量为 0 的地址处</p>
</li>
<li>
<p>第二个及以后的成员，需要在 对齐数的整数倍 的地址处存放</p>
</li>
<li>
<p>结构体的总大小，必须是其成员的最大对齐数的整数倍</p>
</li>
<li>
<p>如果是结构体嵌套了结构体的情况，被嵌套的结构体的对齐数，就是 它内部成员的最大对齐数</p>
</li>
</ol>
<blockquote>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">double</span> n;</span><br><span class="line"> <span class="type">char</span> c1;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">S3</span> <span class="title">s</span>;</span></span><br><span class="line"> <span class="type">char</span> c1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 结构体 <code>struct S4</code>声明中，嵌套了结构体<code>struct S3</code></p>
<p>那么，变量<code>s</code>的对齐数，就是结构体<code>struct S3</code>内部的成员的最大对齐数（为 <code>8</code>），变量<code>s</code>的大小，就是结构体<code>struct S3</code>的大小（为 <code>16</code>）</p>
</blockquote>
</blockquote>
<h4 id="143-为什么存在内存对齐"><a class="markdownIt-Anchor" href="#143-为什么存在内存对齐"></a> 1.4.3 为什么存在内存对齐</h4>
<ol>
<li>
<p>硬件平台原因（移植的问题）</p>
<p>不是所有的硬件平台都能访问 任意地址上 的 任意数据 ；</p>
<p>某些硬件平台只能在 某些地址处 取 某些特定类型的数据（经过对齐的特定类型的数据），否则抛出硬件异常。</p>
</li>
<li>
<p>性能原因</p>
<p>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。<br />
原因在于，若访问未对齐的内存，处理器需要作两次内存访问；而对 对齐的内存访问仅需要一次访问</p>
<blockquote>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&gt;</span>&#123;</span><br><span class="line">&gt;<span class="type">char</span> c;</span><br><span class="line">&gt;<span class="type">int</span> i;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s1</span>;</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>上边的代码，创建了一个结构体变量，我们来假设两种情况</p>
<ol>
<li>假设 不对齐内存</li>
</ol>
  <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124173955115.png" alt="image-20220124173955115" style="zoom:67%;" />
<ol start="2">
<li>假设 对齐内存</li>
</ol>
  <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124174019513.png" alt="image-20220124174019513" style="zoom:67%;" />
<p>假设，我们是 32 位环境，一次可以读取 4 字节</p>
<p>那么对于<code>第一种情况</code>:</p>
<blockquote>
<p>我们要访问完整的 <code>i</code> 的数据，就需要访问两次</p>
</blockquote>
<blockquote>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124174747128.png" alt="image-20220124174747128" style="zoom:67%;" />
</blockquote>
<blockquote>
<p>因为，第一次只访问到了 <code>i</code>的 前三个字节，第二次访问了 <code>i</code> 的最后一个字节</p>
</blockquote>
<p>对于<code>第二种情况</code>：</p>
<blockquote>
<p>我们要访问完整的 <code>i</code> 的数据，只需要一次访问</p>
</blockquote>
<blockquote>
<p>跳过前 4 个字节，直接访问 <code>i</code> 的数据，效率要更高一些</p>
</blockquote>
<blockquote>
 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124175136669.png" alt="image-20220124175136669" style="zoom:67%;" />
</blockquote>
<p>所以，内存对齐，有一定的性能的提升</p>
</blockquote>
<p>所以，结构体的内存对齐，是一种用空间来换取时间的做法。</p>
</li>
</ol>
<h4 id="144-结构体声明设计的优化"><a class="markdownIt-Anchor" href="#144-结构体声明设计的优化"></a> 1.4.4 结构体声明（设计）的优化</h4>
<p>了解了结构体内存对齐，知道了结构体变量内部的成员，在内存中可能并不是紧密排列的，是需要对齐的。是一种拿空间换取时间的做法。</p>
<p>那么有没有一种做法，可以在对其的同时尽量的节省空间呢？</p>
<p>答案是：有！</p>
<p>我们 举过的例子，<code>示例 2</code> 和 <code>示例 3</code> 仅仅是将结构体内部的成员换了一个位置，就节省了 4 个字节的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ↓↓↓</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看过上边的对比，我们发现 <code>c1</code> 和 <code>c2</code> 对空间的占用都很小，都是 <code>1</code> 字节。两个占用内存空间小的变量挤在一起，就能减少空间的浪费。</p>
<p>所以呢，如果 既要满足对齐，还要尽量节省空间，就</p>
<blockquote>
<p>让占用空间小的成员尽量集中在一起</p>
</blockquote>
<h4 id="145-默认对齐数的修改"><a class="markdownIt-Anchor" href="#145-默认对齐数的修改"></a> 1.4.5 默认对齐数的修改</h4>
<p>上边对齐规则中，我们提到 VS编译器中，结构体的 默认对齐数 是8。而在 <code>Linux</code> 平台下的 <code>gcc</code>编译器 是没有默认对齐数的。但是，我们可以通过一个预处理指令 来设置本项目中的默认对齐数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack (n)</span></span><br></pre></td></tr></table></figure>
<p>这句预处理指令是设置默认对齐数用的，<code>n</code> 就是 要设置的默认对齐数的值</p>
<blockquote>
<p>举个栗子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)		<span class="comment">//设置默认对齐数为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c1;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">char</span> c2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%zu&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S1));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220124202355959.png" alt="image-20220124202355959" style="zoom:67%;" />
<p>此时，<code>struct S1</code>的总大小变成了 <code>6</code> 字节，而我们没有改变的时候是 <code>12</code> 字节</p>
</blockquote>
<p>注意！！默认对齐数千万不要乱改，一般改为 2 的次方。</p>
<h3 id="15-结构体传参"><a class="markdownIt-Anchor" href="#15-结构体传参"></a> 1.5 结构体传参</h3>
<p>如果我们想要写一个比如，修改结构体变量、输出结构体变量等功能的函数，就会遇到和其他函数一样的问题——传参。</p>
<p>函数调用结构体变量时，怎么传参给函数呢？</p>
<ol>
<li>
<p>结构体变量直接传参</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s1</span> =</span> &#123; &#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>&#125;, <span class="number">2022</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> S s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    print1(s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结构体变量地址传参</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s1</span> =</span> &#123; &#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>&#125;, <span class="number">2022</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> S* ptrs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptrs-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    print2(&amp;s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上两种结构体的传参方式，大家思考一下，哪一种传参方式好一些，为什么？</p>
<p>先来分析一下，结构体传参，传值和传地址，有什么不同：</p>
<p>如果传值：</p>
<blockquote>
<p>给函数传入结构体变量的值，函数需要将结构体变量的值完全拷贝一份，再存储到形参。可以修改形参的值，但不能直接访问原结构体变量。</p>
</blockquote>
<p>如果传地址：</p>
<blockquote>
<p>给函数传入结构体变量的地址，函数需要将地址拷贝一份，存储至形参。并且可以通过地址，来直接访问原结构体变量。</p>
</blockquote>
<p>所以这样来看，应该是 传结构体地址的方式好一些。具体原因：</p>
<blockquote>
<p>函数传参时，参数是需要压栈的，会有时间和空间上的系统开销。</p>
<p>如果传递一个结构体对象的时候，结构体过大，函数压栈的系统开销就会比较大，会导致项目性能的下降。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言进阶</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
</search>
