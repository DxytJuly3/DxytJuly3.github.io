<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/83b96e9163f5/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/96f888721259/</url>
    <content><![CDATA[<h1 id="内存函数"><a href="#内存函数" class="headerlink" title="内存函数"></a>内存函数</h1><h2 id="1-memcpy"><a href="#1-memcpy" class="headerlink" title="1.memcpy"></a>1.<code>memcpy</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memcpy</span> <span class="params">( <span class="type">void</span>* destination, <span class="type">const</span> <span class="type">void</span>* source, <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure>

<p>作用：<code>strcpy</code> 是用来拷贝字符串的，<code>memcpy</code> 也可以逐字节拷贝其他类型的数据(C语言要求其处理内存空间地址不重叠的数据)(PS：VS中 已经将其优化得可以处理内存空间地址重叠的数据)</p>
<p>模拟实现<code>memcpy</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">my_memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ret = dest;</span><br><span class="line">    assert(dest &amp;&amp; src);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">char</span>*)dest = *(<span class="type">char</span>*)src;</span><br><span class="line">        dest = (<span class="type">char</span>*)dest + <span class="number">1</span>;	<span class="comment">//上边强制类型转换解引用后, dest 的类型依旧是 void*, 无法直接加加, 所以依旧需要强制类型转换</span></span><br><span class="line">        src = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//有返回类型, 必须返回一个值(可忽略此返回值)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-memmove"><a href="#2-memmove" class="headerlink" title="2.memmove"></a>2.<code>memmove</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memmove</span> <span class="params">( <span class="type">void</span> * destination, <span class="type">const</span> <span class="type">void</span> * source, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure>

<p>作用：同<code>memcpy</code>一样，<code>memmove</code> 也可以逐字节拷贝其他类型的数据(C语言要求其处理内存空间地址重叠的数据)</p>
<p>模拟实现<code>memmove</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">my_memmove</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ret = dest;</span><br><span class="line">    assert(dest &amp;&amp; src);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dest &lt; src)</span><br><span class="line">    &#123;<span class="comment">// 从前向后拷贝</span></span><br><span class="line">        <span class="keyword">while</span>(num--)</span><br><span class="line">    	&#123;</span><br><span class="line">        	*(<span class="type">char</span>*)dest = *(<span class="type">char</span>*)src;</span><br><span class="line">        	dest = (<span class="type">char</span>*)dest + <span class="number">1</span>;	<span class="comment">//上边强制类型转换解引用后, dest 的类型依旧是 void*, 无法直接加加, 所以依旧需要强制类型转换</span></span><br><span class="line">        	src = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 从后向前拷贝</span></span><br><span class="line">        <span class="keyword">while</span>(num--)</span><br><span class="line">        	*((<span class="type">char</span>*)dest+num) = *((<span class="type">char</span>*)src+num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//有返回类型, 必须返回一个值(可忽略此返回值)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-memcmp"><a href="#3-memcmp" class="headerlink" title="3. memcmp"></a>3. <code>memcmp</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span> <span class="params">( <span class="type">const</span> <span class="type">void</span> * ptr1, <span class="type">const</span> <span class="type">void</span> * ptr2, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure>

<p>作用：<code>strcmp</code> 是用来比较字符串的，<code>memcmp</code> 也可以逐字节比较其他类型的数据</p>
<h2 id="4-memset"><a href="#4-memset" class="headerlink" title="4. memset"></a>4. <code>memset</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">( <span class="type">void</span> *dest, <span class="type">int</span> c, <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure>

<p>作用：将数组前 <code>num</code> 字节，每个字节赋值为 <code>c</code></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/620655434a2a/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/4cbf022fb582/</url>
    <content><![CDATA[<h1 id="原由"><a href="#原由" class="headerlink" title="原由"></a>原由</h1><p>大家好啊！我是七月<br>上个月发生了一件让许多人破防的一件事：**<code>Gitee 图床炸了</code>**</p>
<p>在 <code>Gitee</code> 上建立的图床里的图片全都变成了 <code>Gitee</code> 的图标：<br><img src="https://img-blog.csdnimg.cn/3ffc2687b14840ef87c27e14844d9cfb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiD5pyISnVseS4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>
<p>这波事故过后一定有许多小伙伴也不敢再在 <code>Gitee</code> 创建图床，免得把再自己给整破防了。<br>肯定有许多小伙伴转到了 <code>阿里云</code> 等云平台服务重新建立了自己的图床。<br>但是在 云平台服务建立图床 <code>不是免费的</code>，无论是空间还是流量都不是免费的。<br>所以，对自己图床访问的限制也就变得尤为重要。<br> <strong><code>不然自己的云服务就可能被爬虫摧残！！</code></strong> <code>(我已经有了惨痛的教训,都是金钱的教训)</code><br>下面就来具体说明一下，<code>如何给自己的图床设置白名单</code>，来阻隔各路爬虫的访问。</p>
<hr>
<h1 id="给图床设置白名单"><a href="#给图床设置白名单" class="headerlink" title="给图床设置白名单"></a>给图床设置白名单</h1><p> 这里以 <code>阿里云</code> 为例 <code>( 阿里云手机暂不支持操作，或者是我没找到如何修改 )</code></p>
<p>首先，在自己的 <code>OSS管理控制台</code> 进入<code>需要设立白名单的Bucket</code><br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/OSS_1.png" alt="请添加图片描述"><br>然后再左边列表选择 <code>权限管理-&gt;防盗链</code><br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/OSS_2.png"></p>
<p>然后找到 <code>开启防盗链</code>，并打开<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/OSS_3.png"></p>
<p>打开后，在 <code>Referer</code> 表里，添加 <code>白名单域名</code> 或 <code>ip</code>  就好了</p>
<h1 id="白名单需要添加什么"><a href="#白名单需要添加什么" class="headerlink" title="白名单需要添加什么"></a>白名单需要添加什么</h1><p><code>白名单(防盗链)</code> 中，添加一般 <code>需要访问图床图片</code> 的 <code>网址</code> 和 <code>ip</code></p>
<p>比如，我们在 <code>C站</code> 写博客需要访问图床外链，就把 <code>C站的域名</code> 添加进去：<code>*.csdn.net</code></p>
<p>或者，需要在 <code>阿里云OSS</code> 预览图片：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/cover_OSS.png"></p>
<p>也需要将 <code>阿里云</code> 的域名添加进去，如果不添加就会变成这样：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/cover_OSS_2.png"></p>
<p>将 <code>需要访问图床图片的网站域名</code> 添加进去之后，指定网站就可以访问获取图片了 !</p>
<p>这里我添加了需要访问图片的域名：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Referer_yuming.png"><br>添加域名的方式，阿里云有给手册 ：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/For_star.png"></p>
<p>添加完成后，就可以<code>防止白名单外的网站访问图床内的图片</code>，就可以 <code>防止爬虫访问导致流量疯狂外流</code>。</p>
<h2 id="添加-ip-建议"><a href="#添加-ip-建议" class="headerlink" title="添加 ip 建议"></a>添加 ip 建议</h2><p>添加完网站域名，我还推荐 <code>将自己常用网络的ip地址</code> 添加至白名单。否则本地访问 图床图片时 会被拒绝导致访问失败。</p>
<p>考虑到有些小伙伴可能不知道自己的 网络 <code>ip</code>，这里提供一下查询方法<code>(Windows平台)</code>：</p>
<blockquote>
<ol>
<li>使用 <code>CMD</code> 指令查看：<br> 先打开 <code>CMD</code> 或 <code>Terminal(Win11)</code>：<br>  <code>CMD</code>：可以 <code>Win + R</code> 组合键唤出  <code>运行</code>，然后输入 <code>CMD</code> 运行就可以<br>  <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/run_CMD.png"></li>
</ol>
</blockquote>
<blockquote>
<p> <code>Terminal(Win11)</code> ：右键 <code>开始按钮</code> 选择 <code>终端(Terminal)</code> 就可以<br> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/run_Terminal.png"></p>
</blockquote>
<blockquote>
<p> 然后在弹出的界面输入 <code>ipconfig /all</code> 回车<br> 就可以找到 <code>当前网络 ip</code>：<br> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/now_ip_adress.png"></p>
<ol start="2">
<li>开始界面打开 <code>设置</code>，并打开 <code>网络与Internet</code>，找到 <code>属性</code> 点击就可以看到 <code>当前网络ip</code>：<br> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/now_ip_adress2.png"></li>
</ol>
</blockquote>
<p>找到自己的 <code>网络 ip</code> 然后添加到 <code>阿里云OSS</code> <code>防盗链(白名单)</code> 里就 OK 啦！ </p>
<hr>
<p>OK 本篇文章到这里就结束了！</p>
<p><code>祝以后的我们的无论使用什么做图床，都不会再挂！！</code></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/817ba7d24c29/</url>
    <content><![CDATA[<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><h2 id="1-strlen"><a href="#1-strlen" class="headerlink" title="1. strlen"></a>1. <code>strlen</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str )</span>;</span><br></pre></td></tr></table></figure>

<p>作用：求字符串中<code>&#39;\0&#39;</code>前的字符串的长度</p>
<p>要求：字符串必须以<code>&#39;\0&#39;</code> 结束</p>
<p>示例</p>
<p>模拟实现 <code>strlen</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可创建临时变量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(*str++)</span><br><span class="line">  		count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 不可创建临时变量 (递归)*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(*str))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>+my_strlen(str+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指针相减 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *pstr = str;</span><br><span class="line">	<span class="keyword">while</span>(*pstr)</span><br><span class="line">		pstr++;</span><br><span class="line">	<span class="keyword">return</span> pstr-str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在MSDN中, <code>strlen</code>函数的返回值是<code>size_t</code>, 也就是 <code>unsigned int</code>无符号整型。返回值是无符号整型，我们在使用函数的时候，如果没有注意到，就可能写出下面这样的代码：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(<span class="string">&quot;asd&quot;</span>) - <span class="built_in">strlen</span>(<span class="string">&quot;asdasd&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;=\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码最终输出的是 <code>&gt;</code> </p>
<p>因为两个无符号整型相减，结果肯定也是无符号整型，所以结果肯定是大于 <code>0</code> 的</p>
</blockquote>
<p>我们模拟实现的<code>my_strlen</code>返回值是 <code>int</code> 类型，就不会出现如果不小心写出错误的代码的问题。</p>
<h2 id="2-strcpy"><a href="#2-strcpy" class="headerlink" title="2. strcpy"></a>2. <code>strcpy</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* destination, <span class="type">const</span> <span class="type">char</span>* source )</span>;</span><br></pre></td></tr></table></figure>

<p>作用：将 <code>source</code> 字符串中的内容(包括<code>&#39;\0&#39;</code>)，拷贝至<code>destination</code>字符串中</p>
<p>要求：被拷贝的字符串(<code>soure</code>)中必须有 <code>&#39;\0&#39;</code>; <code>destination</code>空间必须足够大且可变(不被 <code>const</code> 修饰)</p>
<p>示例</p>
<p>模拟实现 <code>strcpy</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* ret = dest;</span><br><span class="line">    assert(dest &amp;&amp; src);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(*dest++ = *scr++)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-strcat"><a href="#3-strcat" class="headerlink" title="3. strcat"></a>3. <code>strcat</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span> <span class="params">(<span class="type">char</span>* destination, <span class="type">const</span> <span class="type">char</span>* source)</span>;</span><br></pre></td></tr></table></figure>

<p>作用：将 字符串<code>source</code>的内容，追加到字符串<code>destination</code>后</p>
<p>要求：字符串<code>source</code>必须以<code>&#39;\0&#39;</code>结束；字符串<code>destination</code>空间足够大且可修改</p>
<p>示例</p>
<p>模拟实现 <code>strcat</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* ret = dest;</span><br><span class="line">    assert(dest &amp;&amp; src);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(*dest)</span><br><span class="line">    &#123;<span class="comment">//注意：循环里的&quot;++&quot; 不能放入循环条件里: 若放至 dest 后，会跳过原 dest 中的 &#x27;\0&#x27;；若放至 dest 前，如果dest首字符就为&#x27;\0&#x27;也会被跳过</span></span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dest++ = *src++)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-strcmp"><a href="#4-strcmp" class="headerlink" title="4. strcmp"></a>4. <code>strcmp</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span>;</span><br></pre></td></tr></table></figure>

<p>作用：比较两个字符串，对应位置上字符的大小</p>
<blockquote>
<p><code>str1 &gt; str2</code>:	返回一个正数</p>
<p><code>str1 &lt; str2</code>:	返回一个负数</p>
<p><code>str1 == str2</code>:	返回零</p>
</blockquote>
<p>示例</p>
<p>模拟实现 <code>strcmp</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str1 &amp;&amp; str2);</span><br><span class="line">    <span class="keyword">while</span>(*str1 == *str2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*str1 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-strncpy"><a href="#5-strncpy" class="headerlink" title="5. strncpy"></a>5. <code>strncpy</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strncat</span> <span class="params">(<span class="type">char</span>* destination, <span class="type">const</span> <span class="type">char</span>* source, <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure>

<p>受长度限制的字符串拷贝函数</p>
<p>作用：将 字符串<code>source</code>中的前 <code>num</code> 个字符，拷贝到 字符串<code>destination</code>中。</p>
<p>(如果 <code>num</code> 大于 字符串 <code>source</code> 的长度，多出的部分均存入 <code>&#39;\0&#39;</code>)</p>
<h2 id="6-strncat"><a href="#6-strncat" class="headerlink" title="6. strncat"></a>6. <code>strncat</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strncat</span> <span class="params">(<span class="type">char</span>* destination, <span class="type">const</span> <span class="type">char</span>* source, <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure>

<p>受长度限制的字符串追加函数</p>
<p>作用：将 字符串<code>source</code>中的前 <code>num</code> 个字符，追加到 字符串<code>destination</code>后(从第一个<code>&#39;\0&#39;</code>开始算)，并在末尾放入<code>&#39;\0&#39;</code></p>
<p>(如果 <code>num</code> 大于 字符串 <code>source</code> 的长度，则只追加已有的<code>source</code>字符串及末尾的 <code>&#39;\0&#39;</code>)</p>
<h2 id="7-strncmp"><a href="#7-strncmp" class="headerlink" title="7. strncmp"></a>7. <code>strncmp</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2, <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure>

<p>受长度限制的字符串比较函数</p>
<p>作用：比较 字符串 <code>str2</code> 和 <code>str1</code> 对应的前 <code>num</code> 个字符的大小</p>
<h2 id="8-strstr"><a href="#8-strstr" class="headerlink" title="8. strstr"></a>8. <code>strstr</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span>, <span class="type">const</span> <span class="type">char</span>* strCharSet)</span>;</span><br></pre></td></tr></table></figure>

<p>作用：在 字符串<code>string</code>中，查找第一个<code>strCharSet</code>字符串；若<code>strCharSet</code>指向长度为零的字符串(即，<code>strCharSet</code>为空)，则返回原字符串，没找到返回空指针，找到了返回找到的字符串的首字符地址。</p>
<p>示例</p>
<p>模拟实现 <code>strstr</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* substr)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str &amp;&amp; substr);</span><br><span class="line">    <span class="keyword">if</span>(*substr == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    <span class="type">char</span>* flag = (<span class="type">char</span>*)str;	<span class="comment">//记录本次查找的起始地址</span></span><br><span class="line">    <span class="type">char</span>* str1;</span><br><span class="line">    <span class="type">char</span>* str2;					<span class="comment">//记录 查找的字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(*flag)</span><br><span class="line">    &#123;</span><br><span class="line">        str1 = flag;			<span class="comment">//因本次查找中 起始位置需要一直知道，所以将 flag 存入另一个指针变量</span></span><br><span class="line">        str2 = (<span class="type">char</span>*)substr;	<span class="comment">//每次循环从 查找字符串的首字符开始查找</span></span><br><span class="line">        <span class="keyword">while</span>(*st1 &amp;&amp; *str2 &amp;&amp; (*str1 == str2))</span><br><span class="line">        &#123;<span class="comment">/*在此循环中查找，str1 与 str2 指向的字符都不为&#x27;\0&#x27;，且 相等时，继续查找下一个字符</span></span><br><span class="line"><span class="comment">           str2指向的字符为&#x27;\0&#x27;时，查找成功*/</span></span><br><span class="line">            str1++;</span><br><span class="line">            str2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*str2 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        </span><br><span class="line">        flag++;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-strtok"><a href="#9-strtok" class="headerlink" title="9. strtok"></a>9. <code>strtok</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strtok</span> <span class="params">( <span class="type">char</span> * str, <span class="type">const</span> <span class="type">char</span> * sep )</span>;</span><br></pre></td></tr></table></figure>

<p>作用：将字符串分割成一个个片段（自己设定分隔符）</p>
<ul>
<li><p><code>sep</code>参数是个字符串，定义了用作分隔符的字符集合第一个参数指定一个字符串，它包含了0个或者多个由<code>sep</code>字符串中一个或者多个分隔符分割的标记。</p>
</li>
<li><p><code>strtok</code>函数找到<code>str</code>中的下一个标记，并将其用 <code>\0</code> 结尾，返回一个指向这个标记的指针。（注：<code>strtok</code>函数会改变被操作的字符串，所以在使用<code>strtok</code>函数切分的字符串一般都是临时拷贝的内容并且可修改。）</p>
</li>
<li><p><code>strtok</code>函数的第一个参数不为 <code>NULL</code> ，函数将找到<code>str</code>中第一个标记，<code>strtok</code>函数将保存它在字符串中的位置。</p>
</li>
<li><p><code>strtok</code>函数的第一个参数为 <code>NULL </code>，函数将在同一个字符串中被保存的位置开始，查找下一个标记。如果字符串中不存在更多的标记，则返回 <code>NULL</code> 指针。</p>
<blockquote>
<p>即:	1. <code>strtok</code>函数在使用的时候，因为会改变参数，所以第一个参数需要是目标参数的临时拷贝</p>
<ol start="2">
<li><p><code>strtok</code>函数在找第一个标记的时候，函数的第一个参数不是<code>NULL</code></p>
</li>
<li><p><code>strtok</code>函数在找非第一个标记的时候，函数的第一个参数不是<code>NULL</code></p>
</li>
</ol>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;@.&quot;</span>;</span><br><span class="line">&gt;<span class="type">char</span> arr[] = <span class="string">&quot;July3@blog.csdn.net&quot;</span>;</span><br><span class="line">&gt;<span class="type">char</span> arr_copy[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&gt;<span class="built_in">strcpy</span>(arr_copy, arr);</span><br><span class="line">&gt;<span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">&gt;<span class="keyword">for</span>(str = strtok(buf, p); str != <span class="literal">NULL</span>; str = strtok(<span class="literal">NULL</span>, p))</span><br><span class="line">&gt;&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="10-strerror"><a href="#10-strerror" class="headerlink" title="10. strerror"></a>10. <code>strerror</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strerror</span> <span class="params">( <span class="type">int</span> errnum )</span>;</span><br></pre></td></tr></table></figure>

<p>作用：返回错误码，所对应的错误信息。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot; %s\n&quot;</span>, strerror(i));</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 此段代码可测试输出各错误码表示的错误信息</span></span><br></pre></td></tr></table></figure>

<p>实际操作：</p>
<p>在执行某些操作时，可能会遇到一些错误，这时候就需要到这个函数了</p>
<p>例如：C语言操作文件时，遇到错误时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// fopen 函数可以操作文件(返回值，参数，头文件等具体问题，看MSDN)</span></span><br><span class="line">&gt;<span class="comment">// 当库函数使用错误时，会将 errno(C语言提供的全局变量,可直接使用, 需要头文件 errno.h) 赋值为此次库函数使用错误时的错误码</span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">//打开文件</span></span><br><span class="line">   FILE* pf = fopen(<span class="string">&quot;july3.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">NULL</span> == pf)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//读文件</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//关闭文件</span></span><br><span class="line">   fclose(pf);</span><br><span class="line">   pf = <span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="字符分类、字符转换函数"><a href="#字符分类、字符转换函数" class="headerlink" title="字符分类、字符转换函数"></a>字符分类、字符转换函数</h2><table>
<thead>
<tr>
<th align="center">字符分类函数</th>
<th align="center">如果他的参数符合下列条件就返回真</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>iscntrl </code></td>
<td align="center">任何控制字符</td>
</tr>
<tr>
<td align="center"><code>isspace </code></td>
<td align="center">空白字符：空格<code>&#39; &#39;</code>，换页<code>&#39;\f&#39;</code>，换行<code>&#39;\n&#39;</code>，回车<code>&#39;\r&#39;</code>，制表符<code>&#39;\t&#39;</code>或者垂直制表符 <code>&#39;\v&#39;</code></td>
</tr>
<tr>
<td align="center"><code>isdigit </code></td>
<td align="center">十进制数字 0~9</td>
</tr>
<tr>
<td align="center"><code>isxdigit </code></td>
<td align="center">十六进制数字，包括所有十进制数字，小写字母<code>a~f</code>，大写字母<code>A~F</code></td>
</tr>
<tr>
<td align="center"><code>islower </code></td>
<td align="center">小写字母<code>a~z</code></td>
</tr>
<tr>
<td align="center"><code>isupper </code></td>
<td align="center">大写字母<code>A~Z</code></td>
</tr>
<tr>
<td align="center"><code>isalpha </code></td>
<td align="center">字母<code>a~z</code>或<code>A~Z</code></td>
</tr>
<tr>
<td align="center"><code>isalnum </code></td>
<td align="center">字母或者数字，<code>a~z</code>,<code>A~Z</code>,<code>0~9</code></td>
</tr>
<tr>
<td align="center"><code>ispunct </code></td>
<td align="center">标点符号，任何不属于数字或者字母的图形字符（可打印）</td>
</tr>
<tr>
<td align="center"><code>isgraph </code></td>
<td align="center">任何图形字符</td>
</tr>
<tr>
<td align="center"><code>isprint </code></td>
<td align="center">任何可打印字符，包括图形字符和空白字符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">字符转换函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>tolower</code></td>
<td align="center">大写字母转小写字母</td>
</tr>
<tr>
<td align="center"><code>toupper</code></td>
<td align="center">小写字母转大写字母</td>
</tr>
</tbody></table>
<p>[[内存函数]]</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/6ab6006ebadb/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/5d8a59fa3581/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="一-文件的分类"><a href="#一-文件的分类" class="headerlink" title="一. 文件的分类"></a>一. 文件的分类</h2><p>文件按照功能，区分为两类：程序文件、数据文件</p>
<p>两种文件类型的区分是相对的，并不是绝对的</p>
<ol>
<li><p>程序文件</p>
<blockquote>
<p>比如：C语言的源程序文件( <code>.c</code> 为后缀的文件 )</p>
<p>​		   目标文件( 在Windows环境中 以 <code>.obj</code> 为后缀 )</p>
<p>​		   可执行程序文件( 在Windows环境中 以 <code>.exe</code> 为后缀 )</p>
<p>​		   等等</p>
</blockquote>
</li>
<li><p>数据文件</p>
<blockquote>
<p>数据文件的内容，不一定是程序。可以是程序运行时所需要读取、改变的数据。</p>
</blockquote>
</li>
</ol>
<p>为什么说两种文件类型的区分是相对的？</p>
<blockquote>
<p>比如：</p>
<p>存在两个源文件	<code>test1.c</code>	<code>test2.c</code></p>
<p>如果 <code>test1.c</code> 文件可以对 <code>test2.c</code> 文件中的数据进行读取等操作，那么<code>test1.c</code> 就是程序文件，<code>test2.c</code> 就是数据文件。</p>
</blockquote>
<hr>
<p><code>PS：以下讨论的均为数据文件</code></p>
<hr>
<h2 id="二-文件的操作"><a href="#二-文件的操作" class="headerlink" title="二. 文件的操作"></a>二. 文件的操作</h2><h3 id="2-1-文件指针"><a href="#2-1-文件指针" class="headerlink" title="2.1  文件指针"></a>2.1  文件指针</h3><p>在学习文件指针之前，首先来了解一个概念：文件信息区</p>
<p>文件信息区：</p>
<blockquote>
<p>每次打开一个文件，计算机都会在内存中开辟一块区域来存放该文件的各种信息(比如文件名、文件的状态、文件的地址、文件的大小等)。</p>
<p>这些信息都存放在一个结构体变量中，此结构体变量的类型默认被系统声明为 <code>FILE</code>。所以，被使用文件的文件信息区，本质上就是一个<code>FILE</code> 类型的结构体变量。</p>
<p>每当一个文件打开后，计算机会自动根据文件的状态、情况自动生成一个<code>FILE</code>类型的结构体变量，并存入该文件的各种信息。 </p>
</blockquote>
<blockquote>
<p><code>FILE</code> 类型的具体成员，内容。在不同的编译器中是不完全相同的，但是差别不大</p>
</blockquote>
<p>我们使用 <code>FILE</code> 类型定义的结构体指针变量，就是一个文件指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* pf	<span class="comment">//pf 文件指针变量</span></span><br></pre></td></tr></table></figure>

<p>定义 <code>pf</code> 是一个指向 <code>FILE</code> 类型数据的指针变量，可以指向某个文件的文件信息区，通过文件信息区中存放的信息可以进一步访问该文件。<code>所以，通过文件指针变量能够找到与其相关联的文件。</code></p>
<h3 id="2-2-文件的打开与关闭"><a href="#2-2-文件的打开与关闭" class="headerlink" title="2.2  文件的打开与关闭"></a>2.2  文件的打开与关闭</h3><p>文件的打开操作及关闭操作，需要使用两个函数 <code>fopen(文件打开函数)</code> 及 <code>fclose(文件关闭函数)</code></p>
<h4 id="fopen-文件打开"><a href="#fopen-文件打开" class="headerlink" title="fopen 文件打开"></a><code>fopen 文件打开</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode )</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个参数 <code>filename</code>，应该传入 需打开文件的文件名</p>
<p>尽量详细需要打开的文件名，如：<code>C:\\Program Files\\TEST.c</code></p>
<p>若只传入	<code>TEST.c</code>，只会默认打开（创建）<code>.c</code> 文件所在路径的 <code>TEST.c</code> 文件</p>
</blockquote>
<blockquote>
<p>第二个参数 <code>mode</code>，应该传入 表示文件打开模式（方式）的字符串</p>
<p>具体的模式有：</p>
<blockquote>
<p> 表示读写权限的：</p>
<table>
<thead>
<tr>
<th align="center">字符串</th>
<th align="center">权限</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&quot;r&quot;</code></td>
<td align="center"><code>只读</code></td>
<td align="center">只允许读取，不允许写入。文件必须存在，否则打开失败。</td>
</tr>
<tr>
<td align="center"><code>&quot;w&quot;</code></td>
<td align="center"><code>写入</code></td>
<td align="center">若文件不存在，则创建一个新文件；若文件存在，则清空文件内容</td>
</tr>
<tr>
<td align="center"><code>&quot;a&quot;</code></td>
<td align="center"><code>追加</code></td>
<td align="center">若文件不存在，则创建一个新文件；若文件存在，则将写入的数据追加到文件的末尾</td>
</tr>
<tr>
<td align="center"><code>&quot;r+&quot;</code></td>
<td align="center"><code>读写</code></td>
<td align="center">既可以读取也可以写入。文件必须存在，否则打开失败</td>
</tr>
<tr>
<td align="center"><code>&quot;w+&quot;</code></td>
<td align="center"><code>写入</code></td>
<td align="center">既可以读取也可以写入。若文件不存在，则创建一个新文件；若文件存在，则清空文件内容</td>
</tr>
<tr>
<td align="center"><code>&quot;a+&quot;</code></td>
<td align="center"><code>追加</code></td>
<td align="center">既可以读取也可以写入。若文件不存在，则创建一个新文件；若文件存在，则将写入的数据追加到文件的末尾</td>
</tr>
</tbody></table>
<p> 表示读写方式的：</p>
<table>
<thead>
<tr>
<th align="center">字符串</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&quot;t&quot;</code></td>
<td align="center">以文本文件方式读写。</td>
</tr>
<tr>
<td align="center"><code>&quot;b&quot;</code></td>
<td align="center">以二进制文件方式读写。</td>
</tr>
</tbody></table>
<p> 其实，文件打开方式由 r、w、a、t、b、+ 六个字符拼成，各字符的含义是：</p>
<ul>
<li><code>r(read)</code>：读取</li>
<li><code>w(write)</code>：写入</li>
<li><code>a(append)</code>：追加</li>
<li><code>t(text)</code>：文本文件</li>
<li><code>b(binary)</code>：二进制文件</li>
<li><code>+</code>：读取和写入</li>
</ul>
</blockquote>
<p>第二个参数 <code>mode</code> ，传参时，其实 读写权限和读写方式 是结合使用的（但必须将 读写方式 放在 读写权限 的中间或者尾部），不过 读写方式可以忽略不写（忽略的情况下，默认为 <code>&quot;t&quot;</code>，即默认以文本文件的方式进行读写）</p>
<blockquote>
<p>读写权限 及 读写方式 的结合使用，例：</p>
<p>读写方式放在读写权限的尾部 <code>&quot;rt&quot;</code>、<code>&quot;rb&quot;</code>、<code>&quot;r+t&quot;</code>、<code>&quot;r+b&quot;</code>、<code>&quot;wt&quot;</code>、<code>&quot;w+b&quot;</code>、<code>&quot;at&quot;</code>等等</p>
<p>读写方式放在读写权限的中间 <code>&quot;rt+&quot;</code>、<code>&quot;rb+&quot;</code>、<code>&quot;wt+&quot;</code>、<code>&quot;wb+&quot;</code>等等</p>
</blockquote>
</blockquote>
<p><code>fopen</code> 函数的返回值 是 <code>FILE*</code> 类型的，返回的是所打开的文件的文件信息区的首地址，所以需要用 <code>FILE*</code> 类型的指针变量接收，然后可以通过此指针变量操作此文件信息。</p>
<h4 id="fclose-文件关闭"><a href="#fclose-文件关闭" class="headerlink" title="fclose 文件关闭"></a><code>fclose 文件关闭</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">( FILE* stream )</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数的类型是 <code>FILE*</code> 的指针变量，此指针变量 需指向 已打开文件的文件信息区的地址</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//打开文件</span></span><br><span class="line">	FILE * pf = fopen (<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//文件操作</span></span><br><span class="line">     <span class="comment">//…………</span></span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">		fclose (pf);</span><br><span class="line">    	pf = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<hr>
<h3 id="2-3-文件的顺序读写"><a href="#2-3-文件的顺序读写" class="headerlink" title="2.3  文件的顺序读写"></a>2.3  文件的顺序读写</h3><h4 id="2-3-1-文件读写函数"><a href="#2-3-1-文件读写函数" class="headerlink" title="2.3.1 文件读写函数"></a>2.3.1 文件读写函数</h4><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">函数名</th>
<th align="center">函数</th>
<th align="center">适用于</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符输入函数</td>
<td align="center"><code>fgetc</code></td>
<td align="center"><code>int fgetc(FILE* stream);</code></td>
<td align="center">所有输入流</td>
</tr>
<tr>
<td align="center">字符输出函数</td>
<td align="center"><code>fputc</code></td>
<td align="center"><code>int fputc(int c, FILE* stream);</code></td>
<td align="center">所有输出流</td>
</tr>
<tr>
<td align="center">文本行输入函数</td>
<td align="center"><code>fgets</code></td>
<td align="center"><code>char *fgets(char* string, int n, FILE* stream);</code></td>
<td align="center">所有输入流</td>
</tr>
<tr>
<td align="center">文本行输出函数</td>
<td align="center"><code>fputs</code></td>
<td align="center"><code>int fputs(const char* string, FILE* stream);</code></td>
<td align="center">所有输出流</td>
</tr>
<tr>
<td align="center">格式化输入函数</td>
<td align="center"><code>fscanf</code></td>
<td align="center"><code>int fscanf(FILE* stream, const char* format [, argument ]...);</code></td>
<td align="center">所有输入流</td>
</tr>
<tr>
<td align="center">格式化输出函数</td>
<td align="center"><code>fprintf</code></td>
<td align="center"><code>int fprintf(FILE* stream, const char* format [, argument ]...);</code></td>
<td align="center">所有输出流</td>
</tr>
<tr>
<td align="center">二进制输入</td>
<td align="center"><code>fread</code></td>
<td align="center"><code>size_t fread(void* buffer, size_t size, size_t count, FILE* stream );</code></td>
<td align="center">文件</td>
</tr>
<tr>
<td align="center">二进制输出</td>
<td align="center"><code>fwrite</code></td>
<td align="center"><code>size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream );</code></td>
<td align="center">文件</td>
</tr>
</tbody></table>
<p>上面是对 打开的文件进行顺序读写时，可用到的函数。</p>
<hr>
<h4 id="2-3-2-单个字符读写"><a href="#2-3-2-单个字符读写" class="headerlink" title="2.3.2 单个字符读写"></a>2.3.2 单个字符读写</h4><p>使用上边的函数，尝试向文件中写入字符：</p>
<h5 id="fputc-输出字符函数"><a href="#fputc-输出字符函数" class="headerlink" title="fputc 输出字符函数"></a><code>fputc</code> 输出字符函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fputc(<span class="string">&#x27;c&#x27;</span>, pf);</span><br><span class="line">    fputc(<span class="string">&#x27;s&#x27;</span>, pf);</span><br><span class="line">    fputc(<span class="string">&#x27;b&#x27;</span>, pf);</span><br><span class="line">    fputc(<span class="string">&#x27;i&#x27;</span>, pf);</span><br><span class="line">    fputc(<span class="string">&#x27;t&#x27;</span>, pf);</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>fputc</code> 函数成功在文件中写入了内容</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fputc_FILE.png" alt="fputc_FILE"></p>
<p>不过这时候肯定会有疑惑，比如：<code>fputc</code>不是字符输出函数吗？为什么能往文件中输入字符？ </p>
<p>需要知道为什么，就需要学习在文件操作中的以下两个概念：</p>
<blockquote>
<ul>
<li><p>输入</p>
<p>在一般的认知中，用键盘打字，就算是输入了。</p>
<p>但在文件操作中，输入，指 从键盘获取的内容 存入 内存中；也可以指 文件中的内容 存入 内存中。输入的终点，是内存，而不是文件</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-input.png" alt="input"></p>
</li>
<li><p>输出</p>
<p>与输入相反，在文件操作中，把 内存中的数据 输出显示到 屏幕上，或是 输出到 文件中。这就是输出操作。</p>
<p>所以 用 <code>fputc</code> 字符输出函数，往文件中输入字符。</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-output.png" alt="output"></p>
</li>
</ul>
</blockquote>
<p>我们用 <code>fputc</code> 函数，成功向文件中写入了字符，那么如何向屏幕上输出字符呢？需不需要先类似打开文件的操作呢？很显然不需要先打开屏幕什么的。为什么呢？</p>
<p>这里又需要引入三个概念：</p>
<blockquote>
<p>在C语言程序运行时，会默认打开三个流：<br><code>stdin</code>：标准输入流</p>
<p><code>stdout</code>：标准输出流</p>
<p><code>stderr</code>：标准错误流</p>
<p>三个标准流，都是 <code>FILE*</code> 类型的</p>
</blockquote>
<p>当我们需要用<code>fputc</code> 函数，向屏幕输出字符的时候，只需要把目标文件地址改为 标准输出流 就可以了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fputc(<span class="string">&#x27;a&#x27;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;b&#x27;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;c&#x27;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;d&#x27;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fputc_STDOUT.png" alt="fputc_STDOUT"></p>
<p>上面测试了<code>fputc</code> 输出字符函数，那么怎么样使用输入字符函数将文件内的数据，输入至内存中呢？</p>
<h5 id="fgetc-输入字符函数"><a href="#fgetc-输入字符函数" class="headerlink" title="fgetc 输入字符函数"></a><code>fgetc</code> 输入字符函数</h5><p>首先在 <code>.c</code> 源文件的路径下创建 <code>test2.txt</code> 文件，并输入相应的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//以只读方式打开文件，需要先创建文件</span></span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;test2.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ch;</span><br><span class="line">    <span class="comment">//将 fgetc 的返回值存入 ch，再将 ch 内容输出</span></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的运行结果如下(<code>test2.txt</code> 文件 在程序中被打开前 内容就为：<code>abcdefg</code>)：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fgetc_FILE.png" alt="fgetc_FILE"></p>
<p>我们将<code>fgetc</code>的返回值存入 <code>变量ch</code> 并输出，是因为<code>fgetc</code>读取成功的返回值就是读取的内容，屏幕上也输出了 <code>a</code> 、<code>b</code> 、<code>c</code> 、<code>d</code>。</p>
<p>！！！ 这也说明了，如果读取成功，<code>fgetc</code> 函数的返回值就是 读取到的字符的 <code>ASCII</code> 值。</p>
<p>但是<code>ch</code> 为什么不用 <code>char</code> 类型呢？读取的内容不是字符吗？用 <code>char</code> 类型的变量来接收也可以吗？</p>
<p>答案是不行。为什么？</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fgetc_RETURN.png" alt="fgetc_RETURN"></p>
<p>在这句话中我们可以看出，<code>fgetc</code> 将读取到的字符以 <code>int</code> 类型返回 或者 返回 <code>EOF</code>，表示读取错误 或 文件结尾。</p>
<p>说明 <code>fgetc</code> 的返回值，并不一定全都是 字符，也有可能是 <code>EOF</code>。所以我们要用 <code>int</code> 类型的变量接收。</p>
<blockquote>
<p> <code>fgetc</code> 函数，传参传入的是 需要被存放到内存中的 文件的数据 的地址。并且，在程序执行时 屏幕上输出的内容是不同的，意味着 <code>fgetc</code> 函数读到的数据是不同的，但传入的参数均为 <code>变量pf</code>， 这就说明，<code>fgetc</code> 函数会将传入的地址向后移动一位（移动到下一次需要读取的数据的地址）</p>
<p>然后我们回过头来发现，上边我们使用<code>fputc</code> 字符输出函数的时候，每次传入的参数也是同一个变量，但是输出的字符位置却不一样，所以 <code>fputc</code> 函数的使用，也会将传入的地址向后移动一位，以便下一次输出不覆盖之前的输出。</p>
</blockquote>
<hr>
<h4 id="2-3-3-整行字符读写"><a href="#2-3-3-整行字符读写" class="headerlink" title="2.3.3 整行字符读写"></a>2.3.3 整行字符读写</h4><p>对文件的内容一行一行的读写，就需要用到这两个函数</p>
<h5 id="fputs-文本行输出函数"><a href="#fputs-文本行输出函数" class="headerlink" title="fputs 文本行输出函数"></a><code>fputs 文本行输出函数</code></h5><blockquote>
<p><code>fputs</code> 函数 与 <code>fputc</code> 函数的使用方法类似，只不过本函数是输出一行，而另一个是输出单个字符</p>
<p>以下示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;Hello Bit\n&quot;</span>, pf);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;Great\n&quot;</span>, pf);</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fputs_FILE.png" alt="fputs_FILE"></p>
<p>同样的，会改变传入的地址，会将传入的地址 向后移动输出的字符串位数 位</p>
</blockquote>
<h5 id="fgets-文本行输入函数"><a href="#fgets-文本行输入函数" class="headerlink" title="fgets 文本行输入函数"></a><code>fgets 文本行输入函数</code></h5><blockquote>
<p><code>fgets</code> 函数的使用方法，就与 <code>fgetc</code> 函数有很大的不同了。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span>* <span class="built_in">string</span>, <span class="type">int</span> n, FILE* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>三个参数分别代表：</p>
<ul>
<li><code>string</code>：需要输入的字符串地址</li>
<li><code>n</code>：需要输入到第几位</li>
<li><code>stream</code>：读取的文件的文件指针</li>
</ul>
<p>使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 程序运行前需要创建好 test2.txt，并输入相应的内容</span></span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;test2.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> ch[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	fgets(ch, <span class="number">3</span>, pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	fgets(ch, <span class="number">3</span>, pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fgets_FILE.png" alt="fgets_FILE"></p>
<p><code>fgets</code> 函数可以 自定义每次输入的字符长度 ，即 第二个参数 减 1</p>
<p>并且，每次输入到内存中，如果传参不变，会将已经输入到内存中的数据覆盖</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fgets_MEMORY.png" alt="fgets_MEMORY"></p>
<p>若，传参大于文件中数据的长度，则输入完整</p>
<p><code>fgets(ch, 3, pf);</code>  &gt;&gt;&gt;&gt;&gt;&gt;  <code>fgets(ch, 100, pf);</code></p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fgets_FLIE_LONGTH.png" alt="fgets_FLIE_LONGTH"></p>
</blockquote>
<hr>
<h4 id="2-3-4-格式化数据读写"><a href="#2-3-4-格式化数据读写" class="headerlink" title="2.3.4 格式化数据读写"></a>2.3.4 格式化数据读写</h4><p>这里的这个格式化，不是格式化清空的意思。而是 有一定格式的数据，就是格式化数据。比如，结构体等自定义类型。</p>
<p>格式化的读写，需要用到这两个函数 <code>fscanf 格式化输入函数</code> 和 <code>fprintf 格式化输出函数</code> </p>
<p>这两个函数，与 <code>scanf</code> 和 <code>printf</code> 长得很像。其实不仅长得像，用法也很类似：</p>
<h5 id="fprintf-格式化输出函数"><a href="#fprintf-格式化输出函数" class="headerlink" title="fprintf 格式化输出函数"></a><code>fprintf 格式化输出函数</code></h5><blockquote>
<p>用结构体来举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">xxs</span> =</span> &#123;<span class="string">&quot;July&quot;</span>, <span class="number">20</span>, <span class="string">&quot;male&quot;</span>&#125;;</span><br><span class="line">    FILE* pf = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(pf, <span class="string">&quot;%s %d %s&quot;</span>, xxs.name, xxs.age, xxs.sex);</span><br><span class="line">    </span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fprintf_FILE.png" alt="fprintf_FILE"></p>
<p>同样的，可以将文件指针改为 标准输出流 将内存中的数据输出到 屏幕上，这里就不演示了</p>
</blockquote>
<h5 id="fscanf-格式化输入函数"><a href="#fscanf-格式化输入函数" class="headerlink" title="fscanf 格式化输入函数"></a><code>fscanf 格式化输入函数</code></h5><blockquote>
<p>还是用结构体来举例，不过这次是将文件中的数据存入内存中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">   <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">   <span class="type">char</span> sex[<span class="number">10</span>];</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">xxs</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">   FILE* pf = fopen(<span class="string">&quot;test2.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(pf == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="built_in">fscanf</span>(pf, <span class="string">&quot;%s %d %s&quot;</span>, xxs.name, &amp;(xxs.age), xxs.sex);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s&quot;</span>, xxs.name, xxs.age, xxs.sex);</span><br><span class="line">   </span><br><span class="line">   fclose(pf);</span><br><span class="line">   pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fscanf_FILE.png" alt="fscanf_FILE"></p>
</blockquote>
<p>通过两个例子可以看出，<code>fprintf</code> 和 <code>fscanf</code> 两个函数，可以对内存或者文件中的 格式化的数据 进行读写的操作。并且呢，两个函数的的使用方法与 <code>printf</code> <code>scanf</code> 两个函数的使用方法 十分的相似。</p>
<hr>
<h4 id="2-3-5-二进制读写"><a href="#2-3-5-二进制读写" class="headerlink" title="2.3.5 二进制读写"></a>2.3.5 二进制读写</h4><p>二进制的读取和写入，顾名思义，就是将数据从内存以二进制的形式输出到文件（写入文件），或者将二进制的数据从文件中写入到内存（读取文件）</p>
<h5 id="fwrite-二进制输出"><a href="#fwrite-二进制输出" class="headerlink" title="fwrite 二进制输出"></a><code>fwrite 二进制输出</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE* stream )</span>;</span><br></pre></td></tr></table></figure>

<p><code>fwrite</code> 函数，数据从内存以二进制的形式输出到文件（写入文件）</p>
<p>此函数的参数表示的是：</p>
<blockquote>
<ul>
<li><code>const void* buffer</code> ：需要输出到文件的数据</li>
<li><code>size_t size</code> ：需要写入的数据的类型（大小）</li>
<li><code>size_t count</code> ：需要写入的数据的个数</li>
<li><code>FILE* stream</code> ：文件流</li>
</ul>
</blockquote>
<p>二进制输出示例：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&gt;</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> sex[<span class="number">10</span>];</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123; &#123;<span class="string">&quot;CSDN&quot;</span>, <span class="number">15</span>, <span class="string">&quot;Not&quot;</span>&#125;, &#123;<span class="string">&quot;July&quot;</span>, <span class="number">19</span>, <span class="string">&quot;Male&quot;</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">20</span>, <span class="string">&quot;Male&quot;</span>&#125; &#125;;</span><br><span class="line">FILE* pf = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);		<span class="comment">//以二进制输出形式打开文件（写入文件的形式）</span></span><br><span class="line"><span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fwrite(&amp;stu, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Stu), <span class="number">3</span>, pf);</span><br><span class="line"></span><br><span class="line">fclose(pf);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fwrite_FILE.png" alt="fwrite_FILE"></p>
<p>文件以记事本打开，发现数据存在乱码，那么究竟是不是二进制数据呢？</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fwrite_READ.png" alt="fwrite_READ"></p>
<p>以二进制编辑器打开，可以发现确实是二进制数据</p>
</blockquote>
<h5 id="fread-二进制输入"><a href="#fread-二进制输入" class="headerlink" title="fread 二进制输入"></a><code>fread 二进制输入</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span>* buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE* stream )</span>;</span><br></pre></td></tr></table></figure>

<p>二进制输入与二进制输出相反，可以将文件中的二进制数据，输入到内存中（读取文件中的二进制数据）</p>
<p><code>fread</code> 函数的参数表示的是：</p>
<blockquote>
<ul>
<li><code>void* buffer</code> ：需要输入内存的地址</li>
<li><code>size_t size</code> ：读取的文件中的数据的类型的大小</li>
<li><code>size_t count</code> ：读取的数据的个数</li>
<li><code>FILE* stream</code> ：需要读取的文件流</li>
</ul>
</blockquote>
<p>二进制输入（读取二进制数据）的示例：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);		<span class="comment">//以二进制输入形式打开文件（读取文件的形式）</span></span><br><span class="line"> <span class="comment">// 打开的文件就是 上边的示例文件</span></span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fread(&amp;stu, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Stu), <span class="number">3</span>, pf);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s %d %s\n&quot;</span>, stu[<span class="number">0</span>].name, stu[<span class="number">0</span>].age, stu[<span class="number">0</span>].sex);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s %d %s\n&quot;</span>, stu[<span class="number">1</span>].name, stu[<span class="number">1</span>].age, stu[<span class="number">1</span>].sex);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s %d %s\n&quot;</span>, stu[<span class="number">2</span>].name, stu[<span class="number">2</span>].age, stu[<span class="number">2</span>].sex);</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fread_FILE.png" alt="fread_FILE"></p>
</blockquote>
<hr>
<hr>
<p>介绍过这些对文件顺序读写操作函数后，我们发现，这些函数每执行一次，文件指针 就会自然而然地按照排列顺序移动至下一个读写对象。这也就是为什么被称为顺序读写的原因。</p>
<h3 id="2-4-文件的随机读写"><a href="#2-4-文件的随机读写" class="headerlink" title="2.4  文件的随机读写"></a>2.4  文件的随机读写</h3><p>上面介绍的都是对文件进行顺序读写操作时，能使用到的函数。被称为顺序读写操作，是因为以上函数的每一次执行，文件指针就会 按顺序移动至下一个需要读写对象。那么，随机读写又是因为什么呢？</p>
<p>这里的随机并不是不可定的意思，而是不用按照顺序的顺序，具体作何解释，就介绍完随机读写函数在做总结吧。</p>
<h4 id="2-4-1-定位（指定）文件指针"><a href="#2-4-1-定位（指定）文件指针" class="headerlink" title="2.4.1 定位（指定）文件指针"></a>2.4.1 定位（指定）文件指针</h4><h5 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a><code>fseek</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">( FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> origin )</span>;</span><br></pre></td></tr></table></figure>

<p><code>fseek</code> 函数的功能是，根据文件指针 的位置和偏移量 来定位文件指针（或 通过给定文件指针 的位置和偏移量 来指定文件指针的位置）</p>
<p>本函数的参数含义是：</p>
<blockquote>
<ul>
<li><p><code>FILE *stream</code> ：文件流</p>
</li>
<li><p><code>long offset</code> ：偏移量</p>
<p>就是需要指定 文件指针 从初始位置偏移的位数</p>
</li>
<li><p><code>int origin</code> ：文件指针 开始偏移的初始位置</p>
<p>此参数 C语言 给定了三个宏：</p>
<blockquote>
<p><strong>SEEK_CUR</strong></p>
<p>文件指针当前在文件流内容中的位置；（即 不改变文件指针的位置，使文件指针 从当前位置 开始偏移）</p>
<p><strong>SEEK_END</strong></p>
<p>此文件流内容的末尾；（即 将文件指针指向文件流内容的末字符之后，使文件指针 从从文件流内容的末位 开始偏移）</p>
<p><strong>SEEK_SET</strong></p>
<p>此文件流内容的开始；（即 将文件指针指向文件流内容的首位，使文件指针 从文件流内容的首位 开始偏移）</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><code>fseek</code> 函数到底如何使用呢？具体作用究竟是什么呢？：</p>
<blockquote>
<p>首先，我们先创建一个文件（我这里路径是 <code>D:\TEST.txt</code> ），并输入内容</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fseek_TEST.png" alt="fseek_TEST"></p>
<p>当我们不使用 <code>fseek</code> 函数时，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">FILE* pf = fopen(<span class="string">&quot;D:\\TEST.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fopen::%s&quot;</span>, strerror(errno));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;<span class="comment">// 进行 10 次循环 </span></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(pf);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的运行结果是： <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fseek_NOFSEEK.png" alt="fseek_NOFSEEK" style="zoom: 67%;" /> 此时，文件指针应该在 文件内容的 <code>k</code> 字符上。如果再使用 <code>ch = fgetc(pf)</code> ，并输出 <code>ch</code> 存入的字符，将输出 <code>k</code>。</p>
<p>但是如果这时候我们使用 <code>fseek</code> 函数，就可以将文件指针定位到文件内容的其他地方，时文件指针指向的文件内容改变：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">FILE* pf = fopen(<span class="string">&quot;D:\\TEST.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fopen::%s&quot;</span>, strerror(errno));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;<span class="comment">// 进行 10 次循环 </span></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fseek(pf, <span class="number">10</span>, SEEK_CUR);	<span class="comment">//使文件指针，从当前位置向后偏移 10 个字符</span></span><br><span class="line"><span class="comment">//fseek(pf, 15, SEEK_SET);	//使文件指针，从文件内容的首位，向后偏移 15 个字符</span></span><br><span class="line"><span class="comment">//fseek(pf, -5, SEEK_END);	//使文件指针，从文件内容的末字符之后，向后偏移 -5 个字符（向前偏移 5 个字符）</span></span><br><span class="line">   </span><br><span class="line">   ch = fgetc(pf);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">fclose(pf);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><code>fseek</code> 函数，三次使用的运行结果 分别为： </p>
<blockquote>
<p> <code>fseek(pf, 10, SEEK_CUR);</code></p>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fseek_CUR.png" alt="fseek_SEEK_CUR" style="zoom:67%;" />

<p>文件指针从当前位置向后偏移 10 个字符，到 <code>u</code> </p>
</blockquote>
<blockquote>
<p><code>fseek(pf, 15, SEEK_SET);</code></p>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fseek_SET.png" alt="fseek_SEEK_SET" style="zoom:67%;" />

<p>文件指针从文件内容的首位，想后偏移 15 个字符，到 <code>p</code></p>
</blockquote>
<blockquote>
<p><code>fseek(pf, -5, SEEK_END);</code></p>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-fseek_END.png" alt="fseek_SEEK_END" style="zoom:67%;" />

<p>文件字符从文件内容的末字符之后，向 前 偏移 5 个字符，到 <code>v</code></p>
</blockquote>
</blockquote>
<hr>
<h4 id="2-4-2-返回偏移量"><a href="#2-4-2-返回偏移量" class="headerlink" title="2.4.2 返回偏移量"></a>2.4.2 返回偏移量</h4><p>因为对文件进行随机读写操作 可能造成操作者不知道 文件指针此时的位置。所以为了能够确定 文件指针此时指向的位置，就可以使用 <code>ftell</code> 函数。</p>
<h5 id="ftell"><a href="#ftell" class="headerlink" title="ftell"></a><code>ftell</code></h5><p><code>ftell</code> 函数，可以返回 文件指针相对于文件内容初始位置 的偏移量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">( FILE *stream )</span>;</span><br></pre></td></tr></table></figure>

<p><code>ftell</code> 函数没有什么需要特别注意的地方，了解一下如何使用就足够了：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;D:\\TEST.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fopen::%s&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> ret = ftell(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上述代码的运行结果：</p>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-ftell_FILE.png" alt="ftell_FILE" style="zoom:67%;" />  

<p>两次 <code>fget(pf)</code> 之后，计算偏移量 为 <code>2</code>;</p>
</blockquote>
<h4 id="2-4-3-返回初始位置"><a href="#2-4-3-返回初始位置" class="headerlink" title="2.4.3 返回初始位置"></a>2.4.3 返回初始位置</h4><h5 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a><code>rewind</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">( FILE *stream )</span>;</span><br></pre></td></tr></table></figure>

<p><code>rewind</code> 函数可以将 文件指针 重新指向 文件内容的初始位置。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;D:\\TEST.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fopen::%s&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	ch = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> ret = ftell(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">	rewind(pf);</span><br><span class="line">	ret = ftell(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行结果：</p>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-rewind_FILE.png" alt="rewind_FILE" style="zoom:67%;" />
</blockquote>
<hr>
<p>以上就是部分的文件操作函数，并不是全部的文件操作函数，但是文件操作函数就只介绍到这里。</p>
<p>~~ 传统功夫，以点到为止 ~~</p>
<p>如果想要了解 学习更多的 文件操作函数，可以参考 <code>Win32 API</code> 或者 <a href="http://cplusplus.com/">Cplusplus</a> 等网站自行学习 </p>
<p>[[文本文件及二进制文件]]<br>[[文件缓冲区]]<br>[[文件读取结束的判定]]</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/bb6b53a4bb7d/</url>
    <content><![CDATA[<h1 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h1><p>关于<code>文件缓冲区</code> 先来理解一下是怎么形成的：</p>
<p>现行 <code>ANSIC 标准</code> 是采用<code>“缓冲文件系统”</code>处理数据文件的，所谓<code>缓冲文件系统</code>是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块 <code>“文件缓冲区”</code>。</p>
<p>文件缓冲区的作用：</p>
<p>从 <code>内存</code> 向 <code>磁盘</code> 输出数据 会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。</p>
<p>如果从 <code>磁盘</code> 向 <code>计算机</code> 读入数据，则从 磁盘文件中 读取数据输入 到内存缓冲区（充满缓冲区），然后再从 缓冲区逐个地 将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。 </p>
<p>当然，并不是只有在缓冲区被装满的时候，在会执行缓冲区的命令，可以通过手动刷新缓冲区来执行缓冲区中的命令。在一个程序结束的时候，也会刷新清除缓冲区。 换行、以及 fclose 函数也会刷新缓冲区。</p>
<p>文件缓冲区的存在，可以减轻系统的压力。为什么呢？举个栗子：</p>
<p>比如，</p>
<p>执行一个C语言代码，需要在屏幕上打印信息，会用到 printf 函数</p>
<p>这个函数会调用系统调用api，通过系统调用api让操作系统在屏幕上打印信息</p>
<p>但是，如果需要很多次使用 printf，同时也没有缓冲区的存在，那么函数就会频繁的通过系统调用api麻烦操作系统来执行它的命令。但是操作系统并不是只执行这一个程序的，如果只一个程序就频繁的麻烦操作系统，那么如果有更多的程序，操作系统就会承受更多的压力，频繁跳跃与不同的命令。</p>
<p>如果存在缓冲区，那么一个程序中的命令，就会先存储到缓冲区中，当缓冲区被装满之后，再由操作系统 统一执行操作。</p>
<p>类似于问问题，频繁的问问题会让被提问者无法继续当前正在进行的事情。如果存够一定的问题再提问，并且一次性解决，会大大降低提问者和被提问者的压力。</p>
<p>那么怎么证明缓冲区的存在呢？？</p>
<p>在 Windows平台：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fopen failed::%s&quot;</span>, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;Hello Bit&quot;</span>, pf);</span><br><span class="line">	Sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BUFFER-WINDOWS.gif" alt="Windows 平台缓冲区展示" style="zoom:50%;" />

<p>可以看出，在程序编译运行的前5秒，文件中是没有内容的，文件的大小也是 0KB，在程序结束之后，缓冲区虽然并未被装满但是强制被刷新清空，文件中被写入内容。</p>
<p>Linux 平台：</p>
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BUFFER-LINUX.gif" alt="Linux 平台缓冲区展示" style="zoom:50%;" />

<p>可以看出，printf 结尾 有换行符的，都会直接刷新缓冲区，所以每次printf语句执行，都会输出 Hello Bit，但是后面的几句，结尾都没有换行符，所以缓冲区会在程序结束的时候刷新，所以 后面的 Hello Bit，都会在程序结束的时候输出。 </p>
<p>[[文件读取结束的判定]]<br>[[文件操作]]<br>[[文本文件及二进制文件]]</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/c29da5f6728e/</url>
    <content><![CDATA[<h1 id="文本文件、二进制文件及其存储"><a href="#文本文件、二进制文件及其存储" class="headerlink" title="文本文件、二进制文件及其存储"></a>文本文件、二进制文件及其存储</h1><hr>
<p>上一篇介绍过，文件按照功能分类，可以分为 <code>程序文件</code>、<code>数据文件</code> 两类。</p>
<p>此外，文件的分类还有其他的分类方法，比如 按照文件数据的组织形式 来分为 <code>二进制文件</code> 和 <code>文本文件</code>。</p>
<hr>
<h2 id="文本文件和二进制文件"><a href="#文本文件和二进制文件" class="headerlink" title="文本文件和二进制文件"></a>文本文件和二进制文件</h2><p>具体什么是文本文件，什么是二进制文件呢？</p>
<p>关于文本文件，一般我们自己创建并写入内容的文档，或者 Markdown 文件等，都是可以看懂内容的的，这些都属于文本文件的。</p>
<p>比如：</p>
<blockquote>
<p>一个 <code>.txt</code> 文件:  <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-TEXT_FILE.png" alt="TEXT_FILE" style="zoom: 80%;" />，或者 一个 <code>.md</code> 文件 <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BINARY_FILE.png" alt="BINARY_FILE" style="zoom:50%;" /></p>
</blockquote>
<p>而对于二进制文件，一般人打开二进制文件是没有办法直接看懂的，因为大部分内容都是乱码</p>
<p>除非用二进制的编辑器打开才会显示二进制的形式，不过一般人还是无法看懂的</p>
<blockquote>
<p>类似这样：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BINARY_READ1.png" alt="BINARY_READ1"></p>
<p>这样：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BINARY_READ2.png" alt="BINARY_READ2"></p>
<p>或者这样：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BINARY_READ3.png" alt="BINARY_READ3"></p>
<p>类似于，这些文件，一般人（反正我是）真的看不懂。</p>
</blockquote>
<p>这时候可能有人会说</p>
<blockquote>
<p>那 文本文件不就是，打开后 一般人能看懂的文件</p>
<p>二进制文件不就是，打开后内容都是二进制或者乱码形式的一般人看不懂的文件吗</p>
</blockquote>
<p>啊，确实</p>
<p>但是身为新时代青年的我们，不能这样简单的区分</p>
<p>我们要知道，文本文件 和 二进制文件  在内存中都是如何存储的</p>
<p>虽然两种文本的内容在内存中都是以二进制的形式存储的，但是存储的方式又有其他不同。</p>
<h2 id="文本文件在内存中的存储"><a href="#文本文件在内存中的存储" class="headerlink" title="文本文件在内存中的存储"></a>文本文件在内存中的存储</h2><blockquote>
<p>文本文件，我们可以直接打开看懂，主要是因为 文本文件存入内存的二进制数据是经过转换的。</p>
<p>在文本文件的内容 存入内存之前，文本文件的所有内容 都会转换为 <code>ASCII 码</code> 的形式，然后再 以 <code>ASCII 码</code> 的二进制数据存入内存中。</p>
<p>也就是，对于文本文件的内容：</p>
<blockquote>
<p>字符类型、数值类型的数据，都会按位转换为 对应的 <code>ASCII码</code> ，然后将 <code>ASCII码</code>对应的二进制数据，存储到内存中</p>
</blockquote>
<p>然后当使用者打开文本文件的时候，也是会经过转换再显示的。</p>
</blockquote>
<h2 id="二进制文件在内存中的存储"><a href="#二进制文件在内存中的存储" class="headerlink" title="二进制文件在内存中的存储"></a>二进制文件在内存中的存储</h2><blockquote>
<p>二进制文件，直接打开一般会有一部分乱码</p>
<p>是因为，二进制文件的内容，不会全部以 <code>ASCII 码</code> 的形式存入内存中，只有字符型的数据，会转换为相应的 <code>ASCII码</code> 再存储至内存。</p>
<p>所以直接打开二进制文件，字符型以外的数据 就会以乱码的形式展现给用户。</p>
<blockquote>
<p>或许会有 打开二进制文件 却发现中文内容也变成了乱码，那可能是文件内容编码不合适导致的</p>
</blockquote>
</blockquote>
<h2 id="数据在内存中的存储"><a href="#数据在内存中的存储" class="headerlink" title="数据在内存中的存储"></a>数据在内存中的存储</h2><blockquote>
<p>介绍完 <code>文本文件</code> 和 <code>二进制文件</code>，会发现有一个共同点：</p>
<p>字符型的数据，都会先转换为 <code>ASCII码</code> 之后，在存储 <code>ASCII码</code> 的二进制数据。</p>
<p>其实是因为，数据在内存中的存储具体是这样的：</p>
<blockquote>
<ol>
<li>字符型的数据，都会 以其对应的 <code>ASCII码</code> 的二进制存储至内存中</li>
<li>数值型的数据，可以 以其对应的 <code>ASCII码</code> 的二进制存储至内存中（文本文件），也可以 直接以数值本身的二进制形式存储至内存中</li>
</ol>
</blockquote>
<p>那么，数值型的数据 的两种不同形式的存储 有没有什么区别呢？</p>
<p>答案是有的！</p>
<p>举例说明：</p>
<blockquote>
<p>当 我们需要将 99999 存储起来，可以用两种形式：</p>
<blockquote>
<ol>
<li><p>以 <code>ASCII码</code> 的形式存储：</p>
<p>需要将<code>9</code> <code>9</code> <code>9</code> <code>9</code> <code>9</code> 分别转换为字符，然后存储其对应的 <code>ASCII码</code>的二进制</p>
<p>即：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-ASCII.png" alt="DATA_STORAGE-ASCII"></p>
<p><code>VS2013</code>:<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-ASCII-READ.png" alt="ASCII-READ."></p>
</li>
<li><p>直接以数值的二进制存储：</p>
<p>即：<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-BINARY.png" alt="DATA_STORAGE-BINARY"></p>
<p><code>VS2013</code>：对文件中以二进制输出 <code>99999</code></p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-BINARY-READ.png" alt="BINARY-READ1"></p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-DATA_STORAGE-BINARY-READ2.png" alt="BINARY-READ2"></p>
</li>
</ol>
</blockquote>
<p>我们可以非常明确的看到，对于同一个数值型数据，以 <code>99999</code> 为例</p>
<p>如果以 <code>ASCII码</code>形式 存储，占用 5 字节 内存</p>
<p>如果直接以 数值的二进制形式 存储，占用 4 字节 内存</p>
<p>所以，数值型数据的两种不同的存储方式，在内存方面 是有一定的区别的。</p>
</blockquote>
</blockquote>
<p>看完这些，相信都可以理解究竟什么是二进制文件，什么是文本文件了吧！</p>
<hr>
<p>[[文件缓冲区]]<br>[[文件操作]]<br>[[文件读取结束的判定]]</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/76d5519c39be/</url>
    <content><![CDATA[<p>[[结构体]]</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/992eb7b579ca/</url>
    <content><![CDATA[<h1 id="程序执行的过程"><a href="#程序执行的过程" class="headerlink" title="程序执行的过程"></a>程序执行的过程</h1><h2 id="1-程序载入内存："><a href="#1-程序载入内存：" class="headerlink" title="1. 程序载入内存："></a>1. 程序载入内存：</h2><p>程序载入内存分为两种情况：</p>
<ol>
<li>有操作系统环境:<br>打开可执行程序的时候，一般由操作系统自动执行 将程序载入至内存的操作 ( 所以打开程序会有内存占用)</li>
<li>无操作系统环境( 或称为 独立的环境):<br>无操作系统环境的情况，一般适用于：类似 <code>arduino</code>、单片机 等嵌入式开发时。<br>在无操作系统的环境下，一般需要手工将 <code>可执行程序</code> 载入运行平台的内存中，或者直接 <code>将可执行的代码</code> 放入其 <code>只读内存</code> 中</li>
</ol>
<h2 id="2-程序执行开始"><a href="#2-程序执行开始" class="headerlink" title="2. 程序执行开始:"></a>2. 程序执行开始:</h2><p>程序开始执行后的第一个动作就是:<br>寻找程序的入口：<code>main</code> 函数</p>
<h2 id="3-执行程序代码"><a href="#3-执行程序代码" class="headerlink" title="3. 执行程序代码:"></a>3. 执行程序代码:</h2><p>程序的代码开始执行的时候，将会使用一个运行时堆栈（[[函数栈帧]]），用来存储 <code>函数的局部变量</code> 和 <code>返回地址</code> 。<br>还会使用 静态内存区域（堆区），来存储程序代码中的 使用的 <code>静态变量</code></p>
<h2 id="4-程序终止"><a href="#4-程序终止" class="headerlink" title="4. 程序终止"></a>4. 程序终止</h2><p>当程序 在 <code>main</code> 函数中正常返回，就意味着程序正常结束。但也有可能出现程序被中断的现象（程序非正常结束）。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/8bc6baafa0b1/</url>
    <content><![CDATA[<h1 id="预处理详解"><a href="#预处理详解" class="headerlink" title="预处理详解"></a>预处理详解</h1><p>在C语言的代码编写中，经常会见到的 <code>#include </code> <code>#define</code> <code>#pragma</code> 等写在整个代码文件开头的位置，这些 拥有 <code>#</code> 且一般写在 代码开头的语句，就是代码的 <code>预处理指令</code>。</p>
<h2 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h2><p>预定义符号，是 C语言标准 默认内置的宏定义符号。<br>可以直接被拿出使用。</p>
<p>C语言 默认的预定义符号有 5 个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__FILE__  <span class="comment">//进行编译的源文件文件名 (字符串)</span></span><br><span class="line">__LINE__  <span class="comment">//文件当前的行号 （整型）</span></span><br><span class="line">__DATE__  <span class="comment">//文件此次被编译的日期 （字符串）</span></span><br><span class="line">__TIME__  <span class="comment">//文件此次被编译的时间 （字符串）</span></span><br><span class="line">__STDC__  <span class="comment">//当编译器遵循ANSI C时，其值为1，否则未定义</span></span><br></pre></td></tr></table></figure>
<p>用一段代码可以非常直观的表示出 这 5 个预定义符号的特点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;log.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(pf, <span class="string">&quot;%s %s %s %d i=%d \n&quot;</span>, __DATE__, __TIME__, __FILE__, __LINE__, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fclose(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;执行完成\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码执行效果：<br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/PRE-Symbols.png" alt="预定义符号"><br><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/PRE-Symbols-Show.png" alt="预定义符号效果"></p>
<h2 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h2><p>#define </p>
<h3 id="用-define定义-无参宏-标识符"><a href="#用-define定义-无参宏-标识符" class="headerlink" title="用#define定义 无参宏(标识符)"></a>用#define定义 无参宏(标识符)</h3><p>用 #define 来定义无参数的宏，也被成为标识符，是比较简单的</p>
<p>具体的使用，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_PRINT printf(<span class="string">&quot;Today is %s.\n\</span></span></span><br><span class="line"><span class="string"><span class="meta">The time now is %s.\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">						   __TIME__, __DATE__)</span></span><br></pre></td></tr></table></figure>
<p>这些被定义的 <strong>宏</strong> 在使用的时候，是不需要输入参数的，可以直接在代码编写中使用：</p>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/PRE-define-symbol-show.png" alt="define-symbol-show"></p>
<p>截图，使用 <code>uchar</code> 定义了 无符号字符类型变量 <code>c</code><br><code>c &lt; 10</code>， 所以 <code>c</code> 被赋予 <code>Max</code><br>然后使用 <code>TIME_PRINT</code> 来输出时间</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_PRINT printf(<span class="string">&quot;Today is %s.\n\</span></span></span><br><span class="line"><span class="string"><span class="meta">The time now is %s.\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">					   __TIME__, __DATE__)</span></span><br></pre></td></tr></table></figure>
<p>在这一句使用 #define 定义中，第一个 <code>\n</code> 后的  <code>\</code> , 和 <code>,</code>  后的 <code>\</code> ，作用都是续行<br>   如果需要被定义的指令过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠，作用是续行。</p>
</blockquote>
<p>具体用途是：<br>对于较长的固定的，或需要重复使用的某句指令 或 内容，用一个 自定义的标识符 来表示，方便以后统一使用或修改。</p>
<p>#define 定义标识符的规则就是:</p>
<p><code>#define + 自定义标识符 + 需要被自定义的内容</code><br>或者通俗的说<br><code>#define + 新名字(自己起) + 旧名字(原来的)</code></p>
<p>不过需要注意的是，对于 #define 定义的使用，最好不要在指令的末尾加 <code>;</code><br>因为 #define 后第一个字符或字符串 之后的所有内容都是会在 [[编译和链接]] 的过程中 替换掉的<br>在 #define 指令的最后 加上 <code>;</code> ，如果不注意使用 标识符 的话，就可能会造成不必要的错误。</p>
<h3 id="用-define定义-有参宏"><a href="#用-define定义-有参宏" class="headerlink" title="用#define定义 有参宏"></a>用#define定义 有参宏</h3><p>对于有参数的宏，模样 与 使用方法 和函数十分的相似：<br>执行以下代码，对比以下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x, y) ((x)+(y))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ADD(a, b));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Add(a, b));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/PRE_PROCESSING/define_function-pk.png" alt="define_function-pk"><br>结果是，<code>#define</code> 定义的 有参宏 与 自定义的函数，都实现了两数相加的功能。</p>
<p>像这样，对变量大小的相加、相减、比较等简单的代码执行， 有参宏 和 函数都可以实现，不过可以明显地看出，对于比较这些功能的实现，宏的规模和执行，都要比函数要优许多。<br>宏也可以实现，一般函数实现不了的事情，比如：</p>
<blockquote>
<p>当我们需要输出非常多类似这样的语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">the value of a = <span class="number">1</span></span><br><span class="line">the value of b = <span class="number">2</span></span><br><span class="line">the value of c = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>每次输出，<code>=</code>  左右两边的输出值，都会随着输出的 变量名 和 变量数值大小 改变<br>这种实现，函数是实现不了，或者说不容易实现<br>但，这样的操作可以使用宏来实现</p>
</blockquote>
]]></content>
  </entry>
</search>
